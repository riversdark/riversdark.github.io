<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Solving Advent of Code 2025 | Lottery of Babylonian Variations</title><meta name=keywords content><meta name=description content="I took the Solve It with Code course from answer.ai, and Advent of Code is used as practice.
I always thought my Python skills were quite mediocre; I always used to in a &ldquo;just get things done&rdquo; style, so this is also a chance to improve my Python.
For this reason I want to mostly stick with the standard packages and pythonic styles, and only use extra packages when it&rsquo;s too cumbersome otherwise."><meta name=author content="olivier"><link rel=canonical href=https://riversdark.github.io/posts/2026/01/solving-advent-of-code-2025/><link crossorigin=anonymous href=/assets/css/stylesheet.870d54df3a830fe0b647f01b40db4202038c3519b977caf3fa4263ddb5a64f79.css integrity="sha256-hw1U3zqDD+C2R/AbQNtCAgOMNRm5d8rz+kJj3bWmT3k=" rel="preload stylesheet" as=style><link rel=icon href=https://riversdark.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://riversdark.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://riversdark.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://riversdark.github.io/apple-touch-icon.png><link rel=mask-icon href=https://riversdark.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://riversdark.github.io/posts/2026/01/solving-advent-of-code-2025/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js></script><script defer>window.addEventListener("DOMContentLoaded",function(){if(typeof renderMathInElement!="function")return;renderMathInElement(document.body,{delimiters:[{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{aligned}",right:"\\end{aligned}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><meta property="og:url" content="https://riversdark.github.io/posts/2026/01/solving-advent-of-code-2025/"><meta property="og:site_name" content="Lottery of Babylonian Variations"><meta property="og:title" content="Solving Advent of Code 2025"><meta property="og:description" content="I took the Solve It with Code course from answer.ai, and Advent of Code is used as practice.
I always thought my Python skills were quite mediocre; I always used to in a “just get things done” style, so this is also a chance to improve my Python. For this reason I want to mostly stick with the standard packages and pythonic styles, and only use extra packages when it’s too cumbersome otherwise."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-22T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solving Advent of Code 2025"><meta name=twitter:description content="I took the Solve It with Code course from answer.ai, and Advent of Code is used as practice.
I always thought my Python skills were quite mediocre; I always used to in a &ldquo;just get things done&rdquo; style, so this is also a chance to improve my Python.
For this reason I want to mostly stick with the standard packages and pythonic styles, and only use extra packages when it&rsquo;s too cumbersome otherwise."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://riversdark.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Solving Advent of Code 2025","item":"https://riversdark.github.io/posts/2026/01/solving-advent-of-code-2025/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Solving Advent of Code 2025","name":"Solving Advent of Code 2025","description":"I took the Solve It with Code course from answer.ai, and Advent of Code is used as practice.\nI always thought my Python skills were quite mediocre; I always used to in a \u0026ldquo;just get things done\u0026rdquo; style, so this is also a chance to improve my Python. For this reason I want to mostly stick with the standard packages and pythonic styles, and only use extra packages when it\u0026rsquo;s too cumbersome otherwise.\n","keywords":[],"articleBody":"I took the Solve It with Code course from answer.ai, and Advent of Code is used as practice.\nI always thought my Python skills were quite mediocre; I always used to in a “just get things done” style, so this is also a chance to improve my Python. For this reason I want to mostly stick with the standard packages and pythonic styles, and only use extra packages when it’s too cumbersome otherwise.\nThe way AOC works, we have one new puzzle each day, which has two parts: part 1 is often simpler, and can be tackled with brute force; but part 2 would need some more structured thinking, and better algorithmic design.\nAccompanying each day’s input there is also a smaller example input, which is worked out to explain the problem, understand the data and show the expected solution patterns. It’s very helpful as a stepstone to solving the real problem. But it can also be a double edged sword, because there might be patterns or complexities that are present in the real data but not in the example data, so we might be led astray if we rely completely on the example data to construct the solutions.\nhouse keeping The SolveIt method has 4 steps:\nunderstand the problem make a plan carry out the plan review, reflect, refactor The key is to think clearly, go slowly, stop and reflect constantly.\nWe use the aocd package to interact with Advent of Code programmatically.\n1 2 3 import os session = os.getenv('AOC_SESSION') from aocd import get_data, submit, models 1 current_day is only available in December (EST) 01 rotating dials at the entrance We are at the entrance, and there we have a circular dial; its range is 0 to 99; we can turn left (L) or right (R); keep turning right after 99 we arrive at 0, and keep turning left after 0 we arrive at 99; we start at 50, and the input is a series of records for turning left or right; for part 1 we count the total number of times we arrive at 0, after turning the dial; for part 2 we count the total number of times we pass across 0, after turning the dial. 1 2 3 4 5 6 7 8 def parse_2501(data: str) -\u003e list[int]: \"\"\"Parse rotations: L becomes negative, R becomes positive.\"\"\" return [-int(line[1:]) if line[0] == 'L' else int(line[1:]) for line in data.split('\\n')] D01 = models.Puzzle(year=2025, day=1) rotations = parse_2501(D01.input_data) print(len(rotations), rotations[:5]) 1 4042 [29, -3, -46, -25, -38] One of my goals for AOC is to use, as much as possible, only the standard libraries. I felt that there are a lot I can learn in the standard libraries, and my experience with AOC has proven that I was quite right. For part 1, Python’s modulo operator elegantly handles the circular arithmetic—even for negative numbers. (50 - 68) % 100 gives 82, and (-5) % 100 gives 95. This means we don’t need to manually handle wrap-around; just track cumulative position modulo 100 and count zeros.\nSince the landing position can be calculated by accumulatively adding the new turns to the starting position, we can use itertools.accumulate. The function apply a binary function (default to sum) accumulatively to a function, then return a generator of the sequence of results.\n1 2 from itertools import accumulate print(list(accumulate([1, 2, 3, 4], initial=0))) 1 [0, 1, 3, 6, 10] After the accumulative sum we do modulo to see if it lands on zeros.\n1 2 3 4 5 6 7 8 9 10 11 def solve_250101(data: str) -\u003e int: \"\"\"Part 1: Count positions landing exactly on 0. Uses accumulate with initial=50, then applies %100 to get dial positions. O(n) time, O(n) space. \"\"\" rotations = parse_2501(data) positions = [p % 100 for p in accumulate(rotations, initial=50)][1:] return sum(1 for p in positions if p == 0) print(solve_250101(D01.input_data)) 1 969 For part 2, we need to count every time the dial crosses 0 during a rotation, not just when it lands there. My initial idea was to add a large offset (1e6) to convert circular to linear arithmetic, then count “hundred boundaries” crossed. However this turned out to be unnecessary. However we have to be careful to avoid double counting landing positions for a previous turn and the starting position for the next.\nAfter quite some trial and error it turns out, for a move from s to e, the number of zeros crossed depends only on direction:\nGoing right (positive turn): e//100 - s//100 Going left (negative turn): (s-1)//100 - (e-1)//100 The -1 adjustment for leftward moves ensures we count correctly at boundaries: moving left from 10000 to 9999 shouldn’t count as crossing (we started at the boundary), but moving right from 9999 to 10000 should. The logic seems simple in retrospect, but I got stuck here for quite a while!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def solve_250102(data: str) -\u003e int: \"\"\"Part 2: Count all zero-crossings during rotations. Adds offset to linearize circular dial, then counts hundred-boundaries crossed using integer division. Direction matters for boundary handling. O(n) time, O(n) space. \"\"\" rotations = parse_2501(data) ends = list(accumulate(rotations, initial=50)) total = 0 s = ends[0] for t, e in zip(rotations, ends[1:]): if t \u003e 0: # right turn, count as usual total += e // 100 - s // 100 else: # left turn, -1 to avoid double counting total += (s - 1) // 100 - (e - 1) // 100 s = e return total print(solve_250102(D01.input_data)) 1 5887 02 invalid product IDs in the gift shop We are in the gift shop, and we are given a list of product ID ranges; some IDs in those ranges are considered invalid; for part 1 it’s IDs with double repetitions, e.g. 55, 6464, 321321, etc. for part 2 it’s IDs with any number of repetitions, e.g. 55, 555, 64646464, etc. we need to find and sum up all the invalid IDS. When I started doing AOC, data parsing was a huge effort, because I had to sharpen my list comprehension and looping skills. But this got easier as I worked through more puzzles. Come to think about it, perhaps the only thing that computers can do better than humans, are fast iterations? As such it should be a central focus in computer programming. As Alan Perlis would say, “a program without a loop and a structured variable isn’t worth writing.” (Still working on the later!)\n1 2 3 4 5 6 7 8 9 10 11 import numpy as np def parse_2502(data: str) -\u003e list[tuple[str, str]]: \"\"\"Parse input into list of (start, end) string tuples. Keep as strings to preserve digit length information.\"\"\" return [tuple(rng.split('-')) for rng in data.split(',')] D02 = models.Puzzle(year=2025, day=2) data = D02.input_data ranges = parse_2502(data) print(len(ranges),sum(int(e) - int(s) + 1 for s, e in ranges)) 1 38 2178105 For part 1, since we are filtering for double repetitions, only even-length IDs can be invalid, so I filtered the ranges to even-length ranges, and then used integer division/modulo to compare halves. The filtering was made easy by the fact that the maximum length difference between start and end is only 1. This upfront filtering is perhaps unnecessary; I did it mainly to reduce the cognitive load for solving the problem.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def solve_250201(data: str) -\u003e int: \"\"\"Part 1: Sum all double-repetition IDs in ranges. Approach: expand ranges to arrays, use vectorized arithmetic to check if first_half == second_half via division and modulo. O(n) where n = total numbers across all ranges. \"\"\" ranges = parse_2502(data) def filter_range(start: str, end: str) -\u003e tuple[str, str] | None: \"\"\"Filter to even-length numbers only.\"\"\" len_s, len_e = len(start), len(end) s_even, e_even = len_s % 2 == 0, len_e % 2 == 0 if s_even and e_even: return (start, end) elif s_even and not e_even: return (start, '9' * len_s) elif not s_even and e_even: return ('1' + '0' * (len_e - 1), end) else: return None filtered = [r for r in map(lambda x: filter_range(*x), ranges) if r] total = 0 for start, end in filtered: a = np.arange(int(start), int(end) + 1) divider = 10 ** (len(start) // 2) mask = a // divider == a % divider total += a[mask].sum() return total print(solve_250201(D02.input_data)) 1 30608905813 For part 2 any length can be invalid as long as the digits are a repetition of a shorter base (at least two repeats), so we cannot filter out any number and have to check them all. The approach I settled on, is to build up all possible repetition patterns for all number lengths, and then check whether each pattern is found in each range. That’s a huge amount of loops!\nget all the lengths for all ranges. for all lengths, get all their factors. We need to exclude the lengths themselves, since repeating once doesn’t count. for all factor lengths, build up all repetition bases. for all length bases, build up all repetitions that match the target length. since all above work only involves the lengths of the numbers, not the ranges themselves, they can be done upfront. check whether the repets are in any of our ranges. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from sympy import divisors def solve_250202(data: str) -\u003e int: \"\"\"Part 2: Sum all repeated-pattern IDs (≥2 reps) in ranges. Approach: generate all possible repeated-pattern numbers, then filter to those within any range. Much faster than checking every number when candidates are sparse. O(c * r) where c = candidates, r = ranges. \"\"\" ranges = parse_2502(data) # Collect all digit lengths and their proper divisors all_lens = set(len(x) for rng in ranges for x in rng) all_divs = set() for l in all_lens: all_divs.update(divisors(l)[:-1]) # exclude self # Build bases for each divisor length bases = {} for f in all_divs: if f == 1: bases[f] = list(range(1, 10)) else: bases[f] = list(range(10**(f-1), 10**f)) # Generate all candidate repeated-pattern numbers candidates = set() for div in all_divs: for base in bases[div]: for target_len in all_lens: if target_len % div == 0 and target_len \u003e div: candidates.add(int(str(base) * (target_len // div))) # Sum candidates that fall in any range total = 0 for start, end in ranges: s, e = int(start), int(end) for c in candidates: if s \u003c= c \u003c= e: total += c return total print(solve_250202(D02.input_data)) 1 31898925685 I think my solution is quite complicated. I’m not versed in regular expressions, this is one of my weak points. In retrospect, since we are literally just finding patterns in a string, regex seems to be the natural choice. I plan to come back for a regex solution later.\n03 maximum joltages of the lobby escalator we need to get the escalator working by setting it to a maximum power level; we have a list of battery “banks”, each bank in turn is another long list of labelled batteries, we can only choose a certain number of them; the power that each bank supplies is given by concatenating the chosen numbers, e.g. choosing 5 and 6 from 45623 gives us 56; for part 1 we choose 2 of them, for part 2 we choose 12. First parse the data into lists of integers.\n1 2 3 4 5 6 def parse_2503(data: str) -\u003e list[list[int]]: return [[int(c) for c in l] for l in data.splitlines()] D03 = models.Puzzle(year=2025, day=3) banks = parse_2503(D03.input_data) print(len(banks), len(banks[0]), len(banks[-1])) 1 200 100 100 Part 1 looks quite simple: pick the best possible tens digit while leaving one digit for units, then after choosing the tens, choose the largest units digit to its right. It’s all about indexing.\n1 2 3 4 5 6 7 8 9 10 11 12 def solve_250301(data: str) -\u003e int: \"\"\"Part 1: sum of maximum 2-digit joltage per bank.\"\"\" banks = parse_2503(data) total = 0 for line in banks: tens = max(line[:-1]) tens_idx = line.index(tens) units = max(line[tens_idx+1:]) total += int(str(tens) + str(units)) return total print(solve_250301(D03.input_data)) 1 17155 line.index(val) only finds the first index for val, which happens to be exactly what we want.\nPart 2 is the same logic, but with 12 digits, we have to be more careful with the indexing. This is a typical case where the data being processed is changing as the loop progresses, so the most important issue is to keep the target data correctly updated. In this case, since the updated allowed data is a slice of the original list, we only have to keep updating the start and end of the indexing. The key is to always leaving enough room the the rest of the digits.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def solve_250302(data: str) -\u003e int: \"\"\"Part 2: sum of maximum 12-digit joltage per bank.\"\"\" banks = parse_2503(data) total = 0 for line in banks: # loop through each bank start, end = 0, -12+1 # allowed indexing range picks = [] for _ in range(12): # loop through the digits if end == 0: # the last digit requires separate slicing syntax l = line[start:] m = max(l) else: # all digits except the last l = line[start:end] m = max(l) idx = l.index(m) start += idx + 1 end += 1 picks.append(m) total += int(''.join(map(str, picks))) return total print(solve_250302(D03.input_data)) 1 169685670469164 All in all this one is fairly simple, but correctly updating the indices can be tricky if we kept it all in head. I found my current indexing approach rather ugly, especially the -12+1 part, and the fact that I have to use a different indexing syntax for the last digit. Finding each digit is actually indexing a slice of the original list, so we have to accumulate the indices correctly. I had to draw some schematics on paper to get the indexing logic right. I intend to find a better indexing logic once I got the time.\n04 accessible paper rolls in the print shop we have paper rolls in the print shop, arranged on a 2D grid; rolls are denoted by @, empty spaces by .; each roll has up to 8 neighbors (the 3x3 grid around it); a roll is accessible if it has fewer than 4 neighboring rolls; in part 1 we count all accessible rolls in the initial grid; in part 2 we repeatedly remove all accessible rolls, and count how many are removed in total. Parsing the data into a 2D grid.\n1 2 3 4 5 6 7 def parse_2504(data: str) -\u003e list[list[int]]: \"\"\"Parse grid: @ -\u003e 1, . -\u003e 0.\"\"\" return [[1 if c == '@' else 0 for c in line] for line in data.splitlines()] D04 = models.Puzzle(year=2025, day=4) grid = parse_2504(D04.input_data) print(len(grid), len(grid[0])) 1 135 135 Initially I thought about using a tuple of indices for the data, but apparently using a 2D Numpy array would be much simpler. The key is the 3x3 kernel with a zero in the center.\nThis problem is quite similar to the convolution operation in computer vision, so I turned to scipy.ndimage.convolve. But actually the convolution used in computer vision packages, such as PyTorch, is not convolution, but correlation, since mathematically convolution involves flipping the input data first. So the right operation is actually scipy.ndimage.correlate, and padding all borders with 0 is natively supported with the constant mode, and the constant value being set to 0.\nAnd then finding the targets satisfying the creterion is just filtering the results for paper rolls with less than 4 neighbors.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import numpy as np from scipy.ndimage import correlate def solve_250401(data: str) -\u003e int: \"\"\"Part 1: count rolls with \u003c4 neighbors. Uses 8-neighbor correlation with a 3x3 kernel. O(H*W) time, O(H*W) space. \"\"\" grid = parse_2504(data) arr = np.array(grid, dtype=int) kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]], dtype=int) neighbor_counts = correlate(arr, kernel, mode='constant', cval=0) return int(((arr == 1) \u0026 (neighbor_counts \u003c 4)).sum()) print(solve_250401(D04.input_data)) 1 1437 Part 2 is the same neighbor test, but applied repeatedly. Each pass removes the rolls that are currently accessible; we keep looping until no more rolls qualify.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def solve_250402(data: str) -\u003e int: \"\"\"Part 2: iteratively remove accessible rolls and count total removed. Each iteration is O(H*W); the number of iterations depends on structure. \"\"\" grid = parse_2504(data) arr = np.array(grid, dtype=int) kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]], dtype=int) total = 0 while True: neighbor_counts = correlate(arr, kernel, mode='constant', cval=0) mask = (arr == 1) \u0026 (neighbor_counts \u003c 4) count = int(mask.sum()) if count == 0: break total += count arr[mask] = 0 return int(total) print(solve_250402(D04.input_data)) 1 8765 I intend to implement the indexing solution later, without NumPy. In retrospect the problem is quite easy, once we connected it to image processing in computer vision. But this doesn’t come up right away; I only thought of it after spending quite some effort considering how to pad the grid. This shows that I still need practice on some of the basic algorithms.\n05 fresh items in the cafeteria we are in the cafeteria, which keeps a LARGE inventory (large enough to feed a nation!) we have two lists, the first is ranges of possible fresh items, possibly overlapping; the second is the individual items that are currently actually in inventory, some fresh, some probably rotten; for part 1 we need to find all the fresh items in inventory, and count them; for part 2 we need to count how many items are actually in the overlapping fresh item ranges. My original plan was quite simplistic, just turn the lists of ranges into one big set with all the elements, which perfectly solves the partially overlapping problem; then part 1 is simply checking set membership, while part 2 is checking the size of the set. But set is atomic, which means that every element in it has to be independently initiated, and this requires a huge amount of memory: I tried and exhausted the memory before finishing the set initialization.\nThe cleanest practical solution should be deduplicating and merging the overlapping ranges, after ordering them one after another, and then for part 1 we can find the range corresponding to a certain item and check its membership, for part 2 just sum up the range lengths.\n1 2 3 4 5 6 7 8 9 10 def parse_2505(data: str) -\u003e tuple[list[tuple[int, int]], list[int]]: \"\"\"Parse input into (ranges, ids). Ranges are inclusive (lo, hi) tuples.\"\"\" ranges, ids = [part.split('\\n') for part in data.split('\\n\\n')] ranges = [tuple(map(int, rng.split('-'))) for rng in ranges] ids = list(map(int, ids)) return ranges, ids D05 = models.Puzzle(year=2025, day=5) ranges, ids = parse_2505(D05.input_data) print(len(ranges), len(ids)) 1 189 1000 However for part 1, since we only have 1000 items, and 189 ranges to check, we might just check them one by one using brute force. Nonetheless, note that an item is fresh if it’s in any range, so we could stop checking for that item once an enclosing range is found. And any() with a generator expression is quite neat for readable short-circuit membership testing.\n1 2 3 4 5 6 7 8 9 def solve_250501(data: str) -\u003e int: \"\"\"Part 1: Count IDs that fall within any range. O(n*m) where n=IDs, m=ranges. \"\"\" ranges, ids = parse_2505(data) return sum(any(lo \u003c= inv \u003c= hi for lo, hi in ranges) for inv in ids) print(solve_250501(D05.input_data)) 1 840 Once data parsed to the correct format, the solution is just a one-liner. Using generators avoids keeping all the items in memory, and using any we can early stop the membership check once a match is found.\nFor part 2, saying that we need to deduplicate the ranges is neither clear on what the desired result should be like, nor how we could get there. We first need to sort them by starting value, which can be easily dealt with with sorted. Then starting with the first range, we can merge the remaining ranges to it, one by one. The merged result can be a single range, e.g. merging (1, 3) to (1,2) gives simply (1, 3), or a number of disjoint ranges, e.g. merging (4,6) to (1,3) gives [(1,3), (4,6)]. For this reason the starting object must be a list with only one element, not the element itself, i.e. [(1,2),] not (1,2).\nMy initial impression of reduce is largely limited to summary statistics, min, max, argmin, etc. But reduce is actually a general procedure that applies a function of two arguments cumulatively to the items of a sequence or iterable, from left to right, so as to reduce the iterable to a single value. So it’s a perfect fit for what we are trying to achieve.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from functools import reduce def solve_250502(data: str) -\u003e int: \"\"\"Part 2: Count total unique IDs covered by union of all ranges. Classic interval merging algorithm: 1. Sort ranges by start 2. Merge overlapping/adjacent ranges via reduce 3. Sum lengths (+1 for inclusive bounds) \"\"\" ranges, _ = parse_2505(data) sorted_ranges = sorted(ranges) def merge_step(acc, rng): last_start, last_end = acc[-1] next_start, next_end = rng if last_end \u003c next_start: # no overlap acc.append(rng) else: # overlap: extend current range acc[-1] = (last_start, max(last_end, next_end)) return acc merged = reduce(merge_step, sorted_ranges[1:], sorted_ranges[:1]) return sum(hi - lo + 1 for lo, hi in merged) print(solve_250502(D05.input_data)) 1 359913027576322 The use of reduce in this puzzle is inspirational to me. More and more I’m convinced that programming is simply about iteration, once we have the object to be iterated over, and the target to be produced correctly configured (that is, the data structure properly laied out.) All other procedural programs are boilerplates. So again, “a program without a loop and a structured variable is not worth writing”.\n06 cephalopod math in the trash compactor we are given a set of arithmetic problems laid out in a wide grid; the last row has the operators, the rows above are digits for operands; problems are separated by full columns of spaces; part 1 reads numbers by rows (split on whitespace), part 2 reads numbers by columns (trimming the leading or ending whitespaces); once parsed, each problem is just a sum or a product, then we add all results. This is the first time where the difficulty of solving the puzzle lays in parsing the data, rather than solving the problems. There are only 2 operators, multiplication and addition, which should not pose any problem in any modern programming language. In fact, after parsing the data correctly the solution for both parts should be identical.\nFor part 1 the key problem is to split the numbers into groups of problems. This seemingly simple problem is complicated by the fact that all data processing functions I know of (in Python) all process data row by row, while the numbers for each problem are arranged by columns. However this is made easy by a combination of zip(*numbers), which is effectively the transpose function in standard Python. The operator row gives the operator for each problem.\n1 2 3 4 5 6 7 8 9 10 11 def parse_250601(data: str) -\u003e tuple[list[tuple[int, ...]], list[str]]: \"\"\"Part 1 parse: split each row on whitespace, then zip into problems.\"\"\" *number_rows, operator_row = data.splitlines() numbers = [list(map(int, row.split())) for row in number_rows] problems = list(zip(*numbers)) operators = operator_row.split() return problems, operators D06 = models.Puzzle(year=2025, day=6) problems, operators = parse_250601(D06.examples[0].input_data) print(len(problems), problems[0], operators[0]) 1 4 (123, 45, 6) * After parsing the data all that’s left is to compute each problem using its operator and sum everything. Since this exact logic can be used in both parts, I’ve refactored the solver function so that in addition to the data, it also accepts a parser argument.\n1 2 3 4 5 6 7 8 9 10 11 from math import prod def solve_2506(data: str, parser) -\u003e int: \"\"\"Shared solver: apply the operator to each problem, then sum.\"\"\" problems, operators = parser(data) return sum( prod(nums) if op == '*' else sum(nums) for nums, op in zip(problems, operators) ) print(solve_2506(D06.input_data, parse_250601)) 1 6957525317641 Actually we can understand this solution as another parser: parsing the * and + symbols into Python prod and sum functions. But this is rather simple. I plan to study some similar use cases but with more complexity later (Norvig’s lisp interpreters).\nThe parsing logic for part 2 is a bit more convoluted. The problems in part 1 are stored in different columns, and we have to process them into rows (thus the need for transpose), because that’s what our computer is accustomed to process. In part 2, apart from the problems being separated in columns, the operands for each problem are also in columns, so this creates an extra layer of complexity. We can see that most of the difficulty in this puzzle arises because of the fact that we are only accustomed to processing information in a certain fashion, i.e. one row after another. It’s curious that we are so used to processing information row by row, from left to right, and almost all our computer tools are built around this procedure. It’s quite possible that some other civilizations might invent some other procedures that work differently. Classic Chinese, for example, reads column by column, and from right to left.\nBack to the problem, the key is to transpose the character grid, then group contiguous non-blank columns into problems.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from itertools import groupby def parse_250602(data: str) -\u003e tuple[list[tuple[int, ...]], list[str]]: \"\"\"Part 2 parse: read numbers by columns (character-wise).\"\"\" *number_rows, operator_row = data.splitlines() columns = [''.join(chars) for chars in zip(*number_rows)] groups = [ list(group) for is_digit, group in groupby(columns, key=lambda col: col.strip() != '') if is_digit ] problems = [tuple(int(col.strip()) for col in group) for group in groups] operators = operator_row.split() return problems, operators problems, operators = parse_250602(D06.examples[0].input_data) print(len(problems), problems[0], operators[0]) 1 4 (1, 24, 356) * The main novelty here is itertools.groupby, which separates the individual columns into problem groups, by detecting columns that are all whitespaces.\n1 print(solve_2506(D06.input_data, parse_250602)) 1 13215665360076 zip(*list) and itertools.groupby are the new weapons in the arsenal!\n07 splitting beams in the lab Tachyon manifolds we are in a Tachyon manifold, which is simply a 2D grid field; there is (only) one beam of light passing through the field; the beam passes straight through if there is no hindrance, and splits to left and right if encountering a splitter; part 1 needs to count how many splitters have been hit on; part 2 needs to count how many individual paths the beam passe through. Since we need to get the indices of the beams and the splitters, we can parse the data using list comprehension with enumeration. This keep the indices whose values meet a certain creterion. And we can discard the splitter rows that don’t actually have splitters.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse_2507(data: str) -\u003e tuple[set[int], list[set[int]]]: \"\"\"Parse manifold into start column and splitter rows.\"\"\" lines = data.splitlines() start = {i for i, ch in enumerate(lines[0]) if ch == 'S'} splitter_rows = [ {i for i, ch in enumerate(line) if ch == '^'} for line in lines[1:] ] splitter_rows = [s for s in splitter_rows if s] return start, splitter_rows D07 = models.Puzzle(year=2025, day=7) lines = D07.input_data.splitlines() start, splitter_rows = parse_2507(D07.input_data) print(len(lines), len(lines[0])) print(len(splitter_rows), sum(line.count('^') for line in lines)) 1 2 142 141 70 1650 For part 1, a splitter is activated only if:\nthere is a splitter in the first place; a beam is present in the previous row. So this check can be done by comparing the existence of beams in one row, with the existence of splitters in the next row, and this can be done elegantly with set operations. Concretely, A-B are kept as is, and B-A updated with shifts, then we take the union of the two to pass to the next step.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def step_beams(beams: set[int], splitters: set[int]) -\u003e tuple[set[int], int]: \"\"\"Advance beams through one splitter row and count activations.\"\"\" hits = beams \u0026 splitters misses = beams - splitters spawned = {col + d for col in hits for d in (-1, 1)} return misses | spawned, len(hits) def solve_250701(data: str) -\u003e int: \"\"\"Part 1: count activated splitters. O(sum(len(beams) + len(splitters))) across rows. \"\"\" beams, splitter_rows = parse_2507(data) total = 0 for splitters in splitter_rows: beams, activations = step_beams(beams, splitters) total += activations return total print(solve_250701(D07.input_data)) 1 1524 I haven’t used the set operations before, so this has been a useful exercise.\nFor part 2, we need to count the number of distinct paths (timelines) the beam took. My original solution was to store the complete path trajectories, but it turned out to be too memory intensive. Then it occurred to me that we only need to count the number of paths, not trace all of them. This is a big difference, since counting them only requires some summary statistics of the paths, not the paths themselves. In fact, at each step in the manifold, we can count the total spawned paths by counting how many end points there are, and how many distinct paths pass through each ending point. And this info can easily be stored in a dict.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def step_counts(paths: dict[int, int], splitters: set[int]) -\u003e dict[int, int]: \"\"\"Advance all timeline counts through one splitter row.\"\"\" new_paths: dict[int, int] = {} for col, count in paths.items(): if col in splitters: for ncol in (col - 1, col + 1): new_paths[ncol] = new_paths.get(ncol, 0) + count else: new_paths[col] = new_paths.get(col, 0) + count return new_paths def solve_250702(data: str) -\u003e int: \"\"\"Part 2: count timelines after all splits. O(sum(len(paths) + len(splitters))) across rows. \"\"\" beams, splitter_rows = parse_2507(data) paths = {col: 1 for col in beams} for splitters in splitter_rows: # print(paths) paths = step_counts(paths, splitters) return sum(paths.values()) print(solve_250702(D07.input_data)) 1 32982105837605 I had originally had some trouble updating the paths dict, because with splitting beams we have to asign values to keys that doesn’t yet exist. But of course such a common scenario is already covered by an existing dict method dict.get(key, default), which returns the corresponding value is the key exists, and returns a default value otherwise.\nIncidentally today’s puzzle has some terminologies that I don’t know, like Tachyon manifolds, and some connections that I’m not aware of, like quantum fields. Nevertheless this does not in anyway interferes with solving the puzzle. This is a common pattern in computer science, or more specifically algorithm design. A specific problem from a specific domain can be narrated in a specific domain language, but all those specificity can often be abstracted away when devising the algorithm and solving the problem. However this is not saying all the specificities do not matter: on the contrary, simply running a computer program to get an answer is useless, if we can’t apply it back to the specific problems.\n08 connecting junction boxes in the playground We are in a playground with junction boxes, each with a unique 3D coordinate. We repeatedly connect the closest pairs of boxes (by straight-line distance), creating connected groups. For part 1, we process the first 1000 closest pairs (even if some are already connected), then multiply the sizes of the three largest circuits. For part 2, we keep processing closest pairs until all boxes are in one group; then multiply the x coordinates of the last pair that merges the final two circuits. A subtle but important point that confused me in the beginning: the problem says “closest pairs”, not “successful merges.” In the example, after “ten shortest connections” only nine merges happen because one pair was already in the same circuit. So we must process the pairs in order, allowing no-ops.\nWe need to connect individual nodes into separate graphs. The key issues to solve include: 1, which nodes to connect; 2, how to connect; 3, what information to extract from the connected nodes. After figuring out which nodes to connect, which simply calculates the paired distances and rank them, the key problem is graph manipulation. The right abstraction here is Union-Find (disjoint set union). Union, on surface, is connecting two nodes, but in reality it’s connecting the roots of the two nodes, and for this reason we need to know which circuit each box belongs to, and the sizes of those circuits; the actual edges are irrelevant.\n1 2 3 4 5 6 7 def parse_2508(data: str) -\u003e list[tuple[int, int, int]]: \"\"\"Parse coordinates from 'x,y,z' lines.\"\"\" return [tuple(map(int, line.split(','))) for line in data.splitlines()] D08 = models.Puzzle(year=2025, day=8) points = parse_2508(D08.input_data) print(len(points), points[0]) 1 1000 (54996, 20819, 75067) Getting the sorted distance together with the corresponding indices is easy. The distances are used for sorting, while the indices are used later to guide which points to connect, in which order.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from itertools import combinations def sorted_pairs_2508(points: list[tuple[int, int, int]]) -\u003e list[tuple[int, int, int]]: \"\"\"Return (dist2, i, j) for all pairs, sorted by dist2. dist2 is squared Euclidean distance (ordering is unchanged). \"\"\" pairs = [] for i, j in combinations(range(len(points)), 2): x1, y1, z1 = points[i] x2, y2, z2 = points[j] d2 = (x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2 pairs.append((d2, i, j)) return sorted(pairs) The key is the union-find algorithm. Each node is initiated as an independent group, of size 1, with itself as its parent. find traces a graph to its root, it follows parents and compresses the path so future lookups are faster. union merges two roots, updates the size of the new root, and decrements components. We use group_sizes to read off the sizes of all current circuits.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class UnionFind: \"\"\"Disjoint set union with path compression. We keep it simple: always attach one root under the other. \"\"\" def __init__(self, n: int): self.parent = list(range(n)) self.size = [1] * n self.components = n def find(self, x: int) -\u003e int: if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x: int, y: int) -\u003e bool: \"\"\"Merge sets containing x and y. Return True if a merge happened.\"\"\" rx, ry = self.find(x), self.find(y) if rx == ry: return False self.parent[ry] = rx # simply attanch the second group to the first self.size[rx] += self.size[ry] self.components -= 1 return True def group_sizes(self) -\u003e list[int]: return [self.size[i] for i in range(len(self.parent)) if self.parent[i] == i] uf = UnionFind(5) uf.union(0, 1) uf.union(2, 3) print(sorted(uf.group_sizes(), reverse=True), uf.components) # [2, 2, 1], 3 uf.union(1, 3) # merges the {0,1} and {2,3} circuits print(sorted(uf.group_sizes(), reverse=True), uf.components) # [4, 1], 2 1 2 [2, 2, 1] 3 [4, 1] 2 For part 1, process the first 1000 closest pairs, then take the top three circuit sizes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from math import prod def solve_250801(data: str) -\u003e int: \"\"\"Part 1: product of sizes of the three largest circuits. O(n^2 log n) time for sorting all pairs, O(n^2) space. \"\"\" points = parse_2508(data) pairs = sorted_pairs_2508(points) uf = UnionFind(len(points)) for _, i, j in pairs[:1000]: uf.union(i, j) sizes = sorted(uf.group_sizes(), reverse=True) return prod(sizes[:3]) print(solve_250801(D08.input_data)) 1 112230 Part 2 only changes the stopping condition: keep processing closest pairs until there’s a single circuit, and return the product of the x-coordinates of the last successful merge.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solve_250802(data: str) -\u003e int: \"\"\"Part 2: product of x-coordinates from the last merging pair. O(n^2 log n) time for sorting all pairs, O(n^2) space. \"\"\" points = parse_2508(data) pairs = sorted_pairs_2508(points) uf = UnionFind(len(points)) for _, i, j in pairs: if uf.union(i, j) and uf.components == 1: return points[i][0] * points[j][0] print(solve_250802(D08.input_data)) 1 2573952864 It is actually quite difficult to get the right level of abstraction. I wandered about for quite a while till it’s clear that the union-find algorithm should only operate on the indices; and all of the indice operations, with memory, should be included. However, everything else, including the distances and the ranked pair of indices, should NOT be part of this abstraction. This is evident from the fact that the UnionFind class is initiated with only the #nodes and nothing else. This might feel obvious in retrospect, but leaky abstractions caused me a lot of headache before I came up to the right abstraction.\nOnce Union-Find is in place, part 2 just change the stopping rule.\n09 rectangular tile patterns in the movie theatre We are now in the movie theatre, and we are to redecorate the floor, which is covered in tiles of various colors. There are red tiles; between consecutive red tiles there are green tiles; and the interior enclosed by the red/green loop is also green. For part 1, we choose two red tiles as opposite corners of a rectangle and want the maximum area. For part 2, we still want the maximum area, but with the extra requirement that the rectangle must lie entirely on red or green tiles. Parsing the data is trivial.\n1 2 3 4 5 6 7 def parse_2509(data: str) -\u003e list[tuple[int, int]]: \"\"\"Parse red tile coordinates as (x, y) pairs.\"\"\" return [tuple(map(int, line.split(','))) for line in data.splitlines()] D09 = models.Puzzle(year=2025, day=9) red = parse_2509(D09.input_data) print(len(red), red[:3]) 1 496 [(98026, 50027), (98026, 51253), (98365, 51253)] Part 1 is simple. With less than 500 points, try every pair of red tiles as opposite corners is computationally quite feasible.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from itertools import combinations def solve_250901(data: str) -\u003e int: \"\"\"Part 1: maximum rectangle area from two red corners. O(n^2) time, O(1) extra space. \"\"\" red = parse_2509(data) return max( (abs(x2 - x1) + 1) * (abs(y2 - y1) + 1) for (x1, y1), (x2, y2) in combinations(red, 2) ) print(solve_250901(D09.input_data)) 1 4750297200 The only thing worth taking note of is how the area is calculated. The red tiles are squares with areas themselves, not just points (which have no area), and thus the +1 in the formula.\nPart 2 is the real problem of the day. We can still iterate over all pairs of opposite corners, but then we need to check all tiles of the resulting rectangle is in the red-green encircled area. This entails several problems:\nwhat this enclosed area is actually like. This is actually a problem for part 1, but with part 1 being so easy we didn’t even bother to deal with it. how to check if a point is in the enclosed area. This is the core problem. which points we have to check for such enclosion. The enclosed area turns out to be a rectilinear polygon, but I only figured it out after quite some data explorations, including the term rectilinear itself. And to check for enclosion there is a well established algorithm called ray casting, but I know nothing about it. Besides, we are now in a (100K, 100K) area, each rectangle thus has a vast area, so there are a HUGE amount of points to check (if we avoid being clever), the computation has increased immensely.\nI tried to implement the ray casting algorithm, but got buried in the implementation details and edge cases, and I got stuck on the problem for a whole week. Finally I reworked the puzzle after having finished day 10 and 11, and simply used an existing package, shapely, which has established and well polished methods for all 3 issues. So in the end I solved the problem by not solving it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from shapely.geometry import Polygon from shapely.prepared import prep def solve_250902(data: str) -\u003e int: \"\"\"Part 2: maximum rectangle area fully covered by red/green tiles. Uses shapely for containment checks (non-stdlib). O(n^2) rectangle checks; containment is fast with a prepared polygon. \"\"\" red = parse_2509(data) poly = Polygon(red) prepared = prep(poly) best = 0 for (x1, y1), (x2, y2) in combinations(red, 2): xmin, xmax = (x1, x2) if x1 \u003c= x2 else (x2, x1) ymin, ymax = (y1, y2) if y1 \u003c= y2 else (y2, y1) rect = Polygon([(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]) if prepared.covers(rect): area = (xmax - xmin + 1) * (ymax - ymin + 1) if area \u003e best: best = area return best print(solve_250902(D09.input_data)) 1 1578115935 I still need to come back and figure out how to implement the algorithm properly. I tried to look into the shapely implementations, but they are buried in optimized code God knows where. This remains the biggest challange of AOC 2025 for me, and the only case that I considered a failure.\nThere is one solution, which I stumbled upon in the forums, that is a data-compression first approach. This starts by noticing that while the area is large (100K times 100K), we only have less than 500 points, which means that there must by many in-the-middle points that we don’t really have to check. The idea is to do a coordinate compression first, finding out which points in the 100K field actually matters (are the edges and corners), solve the problem on this compressed grid first, and then project back to the original grid to find the areas. The reduced grid being small enough, that we might be able to just brute-force through it. While I still don’t know how to solve it exactly, this is a brilliant approach to simplify the problem, and I intend to try it later.\n10 combining machine switches in the factory We are in the factory, which has a big amount of machines and yet none of them are working. Each machine has N indicator lights, N joltage levels, and M switches; The switches can manipulate both the lights and the joltages; Part 1: find the minimum number of button presses to reach the target on/off pattern; multiple presses of the same buton cancels out. Part 2: ignore the lights and use the same switches to increment counters to target joltage values; now presses are nonnegative integers. For this one, I’m quite proud of myself, for being able to carefully comb through the word soup and parse it to clear matrix multiplication operations and optimization problems. Both parts use the same data format, just different variables, so when refactoring I combined them together with a boolean switch. We have till now mostly parsed data with splitlines or split, but for more complex data patterns we need regular expressions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import re import numpy as np def parse_2510(data: str, use_joltage: bool = False) -\u003e list[tuple[np.ndarray, np.ndarray]]: \"\"\"Return list of (y, XT) where y is target, XT is N x M toggle matrix.\"\"\" parsed = [] for line in data.splitlines(): if use_joltage: target = re.search(r'\\{([0-9,]+)\\}', line).group(1) target = [int(x) for x in target.split(',')] else: diagram = re.search(r'\\[([.#]+)\\]', line).group(1) target = [1 if c == '#' else 0 for c in diagram] switches = re.findall(r'\\(([0-9,]+)\\)', line) indices_list = [[int(s) for s in sw.split(',')] for sw in switches] N = len(target) M = len(indices_list) X = np.zeros((M, N), dtype=int) for i, inds in enumerate(indices_list): X[i, inds] = 1 y = np.array(target, dtype=int).reshape(-1, 1) parsed.append((y, X.T)) return parsed D10 = models.Puzzle(year=2025, day=10) ex = D10.examples[0].input_data data = D10.input_data For part 1 we resorted to brute force exhaustive search, but with early stopping. This is feasible, firstly because the number of switches for each machine is limited. But more importantly because pressing the same switches twice cancels out, we should either press a button, or don’t; the search space for each switch is thus just {0, 1}, so we have a closed exploration space.\nSince we aim to find the minimum number of presses, we search by the number of presses, starting from 1, and early stop once a matching combination is found.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from itertools import combinations from math import comb def construct_ws(M: int, m: int) -\u003e np.ndarray: \"\"\"Create [M, C(M,m)] matrix of switch vectors with exactly m presses.\"\"\" K = comb(M, m) ws = np.zeros((M, K), dtype=int) for i, combo in enumerate(combinations(range(M), m)): ws[list(combo), i] = 1 return ws def solve_251001(data: str) -\u003e int: \"\"\"Part 1: minimum presses to match lights (mod 2). Uses NumPy for matrix multiplication (non-stdlib). \"\"\" parsed = parse_2510(data, use_joltage=False) total = 0 for y, XT in parsed: _, M = XT.shape for m in range(0, M + 1): ws = construct_ws(M, m) ys = (XT @ ws) % 2 if np.any(np.all(ys == y, axis=0)): total += m break return total print(solve_251001(data)) 1 542 The same method won’t work on part 2. Now the targets are positive integers, and each press increases the counter, so the search space is now infinite, which renders exhaustive search pointless. However by formulating the problem as minimizing sum(w) subject to XT @ w = y and w \u003e= 0, it becomes an standard integer linear programming problem, and I simply used SciPy’s linprog with integrality=1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from scipy.optimize import linprog def solve_251002(data: str) -\u003e int: \"\"\"Part 2: minimum presses to match joltage counters (ILP). Uses SciPy linprog with integrality=1. \"\"\" parsed = parse_2510(data, use_joltage=True) total = 0 for y, XT in parsed: M = XT.shape[1] res = linprog(c=[1] * M, A_eq=XT, b_eq=y.ravel(), integrality=1) total += int(round(res.fun)) return total print(solve_251002(data)) 1 20871 I still don’t quite understand why it works, but with some trial and error on some example problems I’ve managed to make it work. I’m always interested in how linear programming works; I intend to implement the algorithm myself later.\n11 counting server paths for the reactor We are given a directed graph of server devices, one line per device; each line is node: child1 child2 ... meaning data flows from node to children; part 1: count all distinct paths from you to out; part 2: count all distinct paths from svr to out that pass through both fft and dac. We simply parse the data into a dict of parent-children pairs, with the children being a set.\n1 2 3 4 5 6 7 8 9 10 11 def parse_2511(data: str) -\u003e dict[str, set[str]]: \"\"\"Parse graph as parent -\u003e children sets.\"\"\" graph: dict[str, set[str]] = {} for line in data.splitlines(): parent, children = line.split(':') graph[parent] = set(children.split()) return graph D11 = models.Puzzle(year=2025, day=11) graph = parse_2511(D11.input_data) print(len(graph), sum(len(v) for v in graph.values())) 1 643 1738 The core of the problem is counting paths in a directed acyclic graph. This is a classic dynamic programming problem, where the problem can be decomposed into multiple subproblems, and each subproblem of the same format as the overall problem. Besides, in each of the subproblem and sub-subproblems, the same computation has to be carried out repeatedly.\nBecause of this, we need to carefully manage two things, formulating the solution in a way that the same problem-solving logic can be reused, and memoization.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from functools import lru_cache def count_paths(graph: dict[str, set[str]], start: str, end: str) -\u003e int: \"\"\"Count paths from start to end in a DAG.\"\"\" @lru_cache(maxsize=None) def dfs(node: str) -\u003e int: if node == end: return 1 return sum(dfs(child) for child in graph.get(node, ())) return dfs(start) def solve_251101(data: str) -\u003e int: \"\"\"Part 1: count paths from you to out. DFS + memoization on node. O(V+E) time, O(V) space. \"\"\" graph = parse_2511(data) return count_paths(graph, start='you', end='out') print(solve_251101(D11.input_data)) 1 574 I originally solved part 1 without considering any edge cases, since there was none; and I didn’t even bother with memoization, since the computation is manageable without it. And then for part 2 I had to patch it up again and again to fix all the edge cases.\nRecursive functions are hard to understand and reason with. It’s better to print out the result of each iteration to understand how it’s stacked up.\nPart 2 adds some constraint: the path must pass through two specific nodes, fft and dac. Since one must be before the other, I used a rather silly approach to determine which is before which, but it worked. My original implementation for part 1 is quite limited, I used it to count #(fft -\u003e dac), if fft is before dac it will not finish, since I didn’t use memoization and it’s very slow; and if dac is before fft it will throw an error, since I didn’t take such reverse direction cases into consideration. So using this weird method I figured out their order in the directed graph, and fft is upstream of dac.\nThat means every valid path factors into three independent segments: and we can count the unique paths of each segment independently, then multiply them together, i.e. #(svr -\u003e fft) * #(fft -\u003e dac) * #(dac -\u003e out).\n1 2 3 4 5 6 7 8 9 10 11 12 13 def solve_251102(data: str) -\u003e int: \"\"\"Part 2: paths from svr to out passing through fft and dac. Factor into three independent path counts. O(V+E) per segment, O(V) space. \"\"\" graph = parse_2511(data) count0 = count_paths(graph, start='svr', end='fft') count1 = count_paths(graph, start='fft', end='dac') count2 = count_paths(graph, start='dac', end='out') return count0 * count1 * count2 print(solve_251102(D11.input_data)) 1 306594217920240 12 fitting present shapes in the Christmas tree farm We are in the Christmas tree farm, we have a number of Christmas presents, in one of the different shapes, all fitted in a 3x3 grid; we also have a list of regions, each a rectangle of a given size, to accomodate the gifts; gifts can be rotated or flipped; to be fitted into the given regions, but without overlap; day 12 has only one problem, to count how many of the given regions can fit all required shapes. Parse the data:\nshapes into a dict of index:shape pairs, regions into a nesting list of region width, length, and a tuple of required shape counts. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def parse_2512(data: str) -\u003e tuple[dict[int, list[str]], list[tuple[int, int, tuple[int, ...]]]]: \"\"\"Parse shapes and region specs.\"\"\" shapes: dict[int, list[str]] = {} regions: list[tuple[int, int, tuple[int, ...]]] = [] current = None rows: list[str] = [] for line in data.splitlines(): if not line: continue if line.endswith(':') and line[:-1].isdigit(): # starting new shapes if current is not None: shapes[current] = rows current = int(line[:-1]) rows = [] elif 'x' in line and ':' in line: # starting new regions area, nums = line.split(':') w, h = map(int, area.split('x')) counts = tuple(map(int, nums.split())) regions.append((w, h, counts)) else: # accumulating lines for current shape rows.append(line) if current is not None: shapes[current] = rows return shapes, regions D12 = models.Puzzle(year=2025, day=12) shapes, regions = parse_2512(D12.input_data) print(len(shapes), len(regions)) 1 6 1000 This is an interesting parsing problem, because the input data have two distinct parts which require different parsing logic. Also, the data parsing is line by line, but each shape takes up multiple lines, so we also need a way to accumulate lines for each shape.\nAs to the problem itself, this is a hard problem with a simple solution. We want to fit a number of irregular shaped presents into a regular rectangular region, there must be a minimum area requirement, where all the shapes fit perfectly together; and a maximum area requirement, where none of the shapes can fit together, and we thus have to spare a 3x3 grid for each of them. We can first check whether each region’s area is in this (minimum, maximum) range, and filter out the regions that ain’t. For regions with area less than the minimum no fitting is possible; for regions with areas bigger than the maximum we can simply put the gifts consecutively, each in a 3x3 grid, so the solution is trivial.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 shape_ids = sorted(shapes) filled = [sum(c == '#' for c in ''.join(shapes[i])) for i in shape_ids] box = [len(shapes[i]) * len(shapes[i][0]) for i in shape_ids] # 3x3 here classifications = [0] * len(regions) for i, (w, h, counts) in enumerate(regions): area = w * h compact = sum(n * f for n, f in zip(counts, filled)) loose = sum(n * b for n, b in zip(counts, box)) if compact \u003e area: # no solution possible classifications[i] = 1 if loose \u003c= area: # no work necessay classifications[i] = 2 for i in [0, 1, 2]: print(i, sum(c==i for c in classifications)) 1 2 3 0 0 1 519 2 481 As it turns out, of the 1000 problem regions, 519 of them are not possible, 481 of them are trivial, and none of them requires actual work. So the feasible ones are identical to the trivial ones.\n1 2 3 4 def solve_2512(data: str) -\u003e int: return sum(c==2 for c in classifications) print(solve_2512(D12.input_data)) 1 481 ","wordCount":"9109","inLanguage":"en","datePublished":"2026-01-22T00:00:00Z","dateModified":"2026-01-22T00:00:00Z","author":[{"@type":"Person","name":"olivier"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://riversdark.github.io/posts/2026/01/solving-advent-of-code-2025/"},"publisher":{"@type":"Organization","name":"Lottery of Babylonian Variations","logo":{"@type":"ImageObject","url":"https://riversdark.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://riversdark.github.io/ accesskey=h title="Lottery of Babylonian Variations (Alt + H)">Lottery of Babylonian Variations</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://riversdark.github.io/ title=Home><span>Home</span></a></li><li><a href=https://riversdark.github.io/stats/ title=Stats><span>Stats</span></a></li><li><a href=https://riversdark.github.io/culture/ title=Culture><span>Culture</span></a></li><li><a href=https://riversdark.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://riversdark.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Solving Advent of Code 2025</h1><div class=post-meta><span title='2026-01-22 00:00:00 +0000 UTC'>January 22, 2026</span>&nbsp;·&nbsp;<span>9109 words</span>&nbsp;·&nbsp;<span>olivier</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#house-keeping>house keeping</a></li><li><a href=#01-rotating-dials-at-the-entrance>01 rotating dials at the entrance</a></li><li><a href=#02-invalid-product-ids-in-the-gift-shop>02 invalid product IDs in the gift shop</a></li><li><a href=#03-maximum-joltages-of-the-lobby-escalator>03 maximum joltages of the lobby escalator</a></li><li><a href=#04-accessible-paper-rolls-in-the-print-shop>04 accessible paper rolls in the print shop</a></li><li><a href=#05-fresh-items-in-the-cafeteria>05 fresh items in the cafeteria</a></li><li><a href=#06-cephalopod-math-in-the-trash-compactor>06 cephalopod math in the trash compactor</a></li><li><a href=#07-splitting-beams-in-the-lab-tachyon-manifolds>07 splitting beams in the lab Tachyon manifolds</a></li><li><a href=#08-connecting-junction-boxes-in-the-playground>08 connecting junction boxes in the playground</a></li><li><a href=#09-rectangular-tile-patterns-in-the-movie-theatre>09 rectangular tile patterns in the movie theatre</a></li><li><a href=#10-combining-machine-switches-in-the-factory>10 combining machine switches in the factory</a></li><li><a href=#11-counting-server-paths-for-the-reactor>11 counting server paths for the reactor</a></li><li><a href=#12-fitting-present-shapes-in-the-christmas-tree-farm>12 fitting present shapes in the Christmas tree farm</a></li></ul></nav></div></details></div><div class=post-content><p>I took the Solve It with Code course from answer.ai, and Advent of Code is used as practice.</p><p>I always thought my Python skills were quite mediocre; I always used to in a &ldquo;just get things done&rdquo; style, so this is also a chance to improve my Python.
For this reason I want to mostly stick with the standard packages and pythonic styles, and only use extra packages when it&rsquo;s too cumbersome otherwise.</p><p>The way AOC works, we have one new puzzle each day, which has two parts: part 1 is often simpler, and can be tackled with brute force; but part 2 would need some more structured thinking, and better algorithmic design.</p><p>Accompanying each day&rsquo;s input there is also a smaller example input, which is worked out to explain the problem, understand the data and show the expected solution patterns.
It&rsquo;s very helpful as a stepstone to solving the real problem. But it can also be a double edged sword, because there might be patterns or complexities that are present in the real data but not in the example data, so we might be led astray if we rely completely on the example data to construct the solutions.</p><h2 id=house-keeping>house keeping<a hidden class=anchor aria-hidden=true href=#house-keeping>#</a></h2><p>The SolveIt method has 4 steps:</p><ol><li>understand the problem</li><li>make a plan</li><li>carry out the plan</li><li>review, reflect, refactor</li></ol><p>The key is to think clearly, go slowly, stop and reflect constantly.</p><p>We use the <code>aocd</code> package to interact with Advent of Code programmatically.</p><p><a id=code-snippet--aocd></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=n>session</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>getenv</span><span class=p>(</span><span class=s1>&#39;AOC_SESSION&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>aocd</span> <span class=kn>import</span> <span class=n>get_data</span><span class=p>,</span> <span class=n>submit</span><span class=p>,</span> <span class=n>models</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>current_day is only available in December (EST)
</span></span></code></pre></td></tr></table></div></div><h2 id=01-rotating-dials-at-the-entrance>01 rotating dials at the entrance<a hidden class=anchor aria-hidden=true href=#01-rotating-dials-at-the-entrance>#</a></h2><ol><li>We are at the entrance, and there we have a circular dial;</li><li>its range is 0 to 99;</li><li>we can turn left (L) or right (R);</li><li>keep turning right after 99 we arrive at 0, and keep turning left after 0 we arrive at 99;</li><li>we start at 50, and the input is a series of records for turning left or right;</li><li>for part 1 we count the total number of times we <strong>arrive at 0</strong>, after turning the dial;</li><li>for part 2 we count the total number of times we <strong>pass across 0</strong>, after turning the dial.</li></ol><p><a id=code-snippet--D01-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2501</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse rotations: L becomes negative, R becomes positive.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=o>-</span><span class=nb>int</span><span class=p>(</span><span class=n>line</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span> <span class=k>if</span> <span class=n>line</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;L&#39;</span> <span class=k>else</span> <span class=nb>int</span><span class=p>(</span><span class=n>line</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D01</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>rotations</span> <span class=o>=</span> <span class=n>parse_2501</span><span class=p>(</span><span class=n>D01</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>rotations</span><span class=p>),</span> <span class=n>rotations</span><span class=p>[:</span><span class=mi>5</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>4042 [29, -3, -46, -25, -38]
</span></span></code></pre></td></tr></table></div></div><p>One of my goals for AOC is to use, as much as possible, only the standard libraries. I felt that there are a lot I can learn in the standard libraries, and my experience with AOC has proven that I was quite right.
For part 1, Python&rsquo;s modulo operator elegantly handles the circular arithmetic—even for negative numbers. <code>(50 - 68) % 100</code> gives 82, and <code>(-5) % 100</code> gives 95. This means we don&rsquo;t need to manually handle wrap-around; just track cumulative position modulo 100 and count zeros.</p><p>Since the landing position can be calculated by accumulatively adding the new turns to the starting position, we can use <code>itertools.accumulate</code>. The function apply a binary function (default to sum) accumulatively to a function, then return a generator of the sequence of results.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>accumulate</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>accumulate</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>],</span> <span class=n>initial</span><span class=o>=</span><span class=mi>0</span><span class=p>)))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[0, 1, 3, 6, 10]
</span></span></code></pre></td></tr></table></div></div><p>After the accumulative sum we do modulo to see if it lands on zeros.</p><p><a id=code-snippet--D01-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250101</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: Count positions landing exactly on 0.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Uses accumulate with initial=50, then applies %100 to get dial positions.
</span></span></span><span class=line><span class=cl><span class=s2>    O(n) time, O(n) space.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>rotations</span> <span class=o>=</span> <span class=n>parse_2501</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>positions</span> <span class=o>=</span> <span class=p>[</span><span class=n>p</span> <span class=o>%</span> <span class=mi>100</span> <span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>accumulate</span><span class=p>(</span><span class=n>rotations</span><span class=p>,</span> <span class=n>initial</span><span class=o>=</span><span class=mi>50</span><span class=p>)][</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=mi>1</span> <span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>positions</span> <span class=k>if</span> <span class=n>p</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250101</span><span class=p>(</span><span class=n>D01</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>969
</span></span></code></pre></td></tr></table></div></div><p>For part 2, we need to count every time the dial <strong>crosses</strong> 0 during a rotation, not just when it lands there. My initial idea was to add a large offset (1e6) to convert circular to linear arithmetic, then count &ldquo;hundred boundaries&rdquo; crossed. However this turned out to be unnecessary. However we have to be careful to avoid double counting landing positions for a previous turn and the starting position for the next.</p><p>After quite some trial and error it turns out, for a move from <code>s</code> to <code>e</code>, the number of zeros crossed depends only on direction:</p><ul><li>Going right (positive turn): <code>e//100 - s//100</code></li><li>Going left (negative turn): <code>(s-1)//100 - (e-1)//100</code></li></ul><p>The <code>-1</code> adjustment for leftward moves ensures we count correctly at boundaries: moving left from 10000 to 9999 shouldn&rsquo;t count as crossing (we started <strong>at</strong> the boundary), but moving right from 9999 to 10000 should. The logic seems simple in retrospect, but I got stuck here for quite a while!</p><p><a id=code-snippet--D01-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250102</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: Count all zero-crossings during rotations.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Adds offset to linearize circular dial, then counts hundred-boundaries
</span></span></span><span class=line><span class=cl><span class=s2>    crossed using integer division. Direction matters for boundary handling.
</span></span></span><span class=line><span class=cl><span class=s2>    O(n) time, O(n) space.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>rotations</span> <span class=o>=</span> <span class=n>parse_2501</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ends</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>accumulate</span><span class=p>(</span><span class=n>rotations</span><span class=p>,</span> <span class=n>initial</span><span class=o>=</span><span class=mi>50</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>ends</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>t</span><span class=p>,</span> <span class=n>e</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>rotations</span><span class=p>,</span> <span class=n>ends</span><span class=p>[</span><span class=mi>1</span><span class=p>:]):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>t</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span> <span class=c1># right turn, count as usual</span>
</span></span><span class=line><span class=cl>            <span class=n>total</span> <span class=o>+=</span> <span class=n>e</span> <span class=o>//</span> <span class=mi>100</span> <span class=o>-</span> <span class=n>s</span> <span class=o>//</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span> <span class=c1># left turn, -1 to avoid double counting</span>
</span></span><span class=line><span class=cl>            <span class=n>total</span> <span class=o>+=</span> <span class=p>(</span><span class=n>s</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>//</span> <span class=mi>100</span> <span class=o>-</span> <span class=p>(</span><span class=n>e</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>//</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>=</span> <span class=n>e</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250102</span><span class=p>(</span><span class=n>D01</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>5887
</span></span></code></pre></td></tr></table></div></div><h2 id=02-invalid-product-ids-in-the-gift-shop>02 invalid product IDs in the gift shop<a hidden class=anchor aria-hidden=true href=#02-invalid-product-ids-in-the-gift-shop>#</a></h2><ol><li>We are in the gift shop, and we are given a list of product ID ranges;</li><li>some IDs in those ranges are considered invalid;</li><li>for part 1 it&rsquo;s IDs with double repetitions, e.g. 55, 6464, 321321, etc.</li><li>for part 2 it&rsquo;s IDs with any number of repetitions, e.g. 55, 555, 64646464, etc.</li><li>we need to find and sum up all the invalid IDS.</li></ol><p>When I started doing AOC, data parsing was a huge effort, because I had to sharpen my list comprehension and looping skills. But this got easier as I worked through more puzzles.
Come to think about it, perhaps the only thing that computers can do better than humans, are fast iterations? As such it should be a central focus in computer programming. As Alan Perlis would say, &ldquo;a program without a loop and a structured variable isn&rsquo;t worth writing.&rdquo; (Still working on the later!)</p><p><a id=code-snippet--D02-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2502</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse input into list of (start, end) string tuples.
</span></span></span><span class=line><span class=cl><span class=s2>    Keep as strings to preserve digit length information.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=nb>tuple</span><span class=p>(</span><span class=n>rng</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;-&#39;</span><span class=p>))</span> <span class=k>for</span> <span class=n>rng</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;,&#39;</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D02</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=n>D02</span><span class=o>.</span><span class=n>input_data</span>
</span></span><span class=line><span class=cl><span class=n>ranges</span> <span class=o>=</span> <span class=n>parse_2502</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>ranges</span><span class=p>),</span><span class=nb>sum</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>e</span><span class=p>)</span> <span class=o>-</span> <span class=nb>int</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span> <span class=k>for</span> <span class=n>s</span><span class=p>,</span> <span class=n>e</span> <span class=ow>in</span> <span class=n>ranges</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>38 2178105
</span></span></code></pre></td></tr></table></div></div><p>For part 1, since we are filtering for double repetitions, only even-length IDs can be invalid, so I filtered the ranges to even-length ranges, and then used integer division/modulo to compare halves. The filtering was made easy by the fact that the maximum length difference between start and end is only 1. This upfront filtering is perhaps unnecessary; I did it mainly to reduce the cognitive load for solving the problem.</p><p><a id=code-snippet--D02-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250201</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: Sum all double-repetition IDs in ranges.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Approach: expand ranges to arrays, use vectorized arithmetic
</span></span></span><span class=line><span class=cl><span class=s2>    to check if first_half == second_half via division and modulo.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    O(n) where n = total numbers across all ranges.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ranges</span> <span class=o>=</span> <span class=n>parse_2502</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>filter_range</span><span class=p>(</span><span class=n>start</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>end</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>]</span> <span class=o>|</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;Filter to even-length numbers only.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>len_s</span><span class=p>,</span> <span class=n>len_e</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>start</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>s_even</span><span class=p>,</span> <span class=n>e_even</span> <span class=o>=</span> <span class=n>len_s</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span> <span class=n>len_e</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>s_even</span> <span class=ow>and</span> <span class=n>e_even</span><span class=p>:</span> <span class=k>return</span> <span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>s_even</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>e_even</span><span class=p>:</span> <span class=k>return</span> <span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=s1>&#39;9&#39;</span> <span class=o>*</span> <span class=n>len_s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=ow>not</span> <span class=n>s_even</span> <span class=ow>and</span> <span class=n>e_even</span><span class=p>:</span> <span class=k>return</span> <span class=p>(</span><span class=s1>&#39;1&#39;</span> <span class=o>+</span> <span class=s1>&#39;0&#39;</span> <span class=o>*</span> <span class=p>(</span><span class=n>len_e</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span> <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>filtered</span> <span class=o>=</span> <span class=p>[</span><span class=n>r</span> <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>filter_range</span><span class=p>(</span><span class=o>*</span><span class=n>x</span><span class=p>),</span> <span class=n>ranges</span><span class=p>)</span> <span class=k>if</span> <span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span> <span class=ow>in</span> <span class=n>filtered</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>start</span><span class=p>),</span> <span class=nb>int</span><span class=p>(</span><span class=n>end</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>divider</span> <span class=o>=</span> <span class=mi>10</span> <span class=o>**</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>start</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>mask</span> <span class=o>=</span> <span class=n>a</span> <span class=o>//</span> <span class=n>divider</span> <span class=o>==</span> <span class=n>a</span> <span class=o>%</span> <span class=n>divider</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>mask</span><span class=p>]</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250201</span><span class=p>(</span><span class=n>D02</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>30608905813
</span></span></code></pre></td></tr></table></div></div><p>For part 2 any length can be invalid as long as the digits are a repetition of a shorter base (at least two repeats), so we cannot filter out any number and have to check them all.
The approach I settled on, is to build up all possible repetition patterns for all number lengths, and then check whether each pattern is found in each range. That&rsquo;s a huge amount of loops!</p><ol><li>get all the lengths for all ranges.</li><li>for all lengths, get all their factors. We need to exclude the lengths themselves, since repeating once doesn&rsquo;t count.</li><li>for all factor lengths, build up all repetition bases.</li><li>for all length bases, build up all repetitions that match the target length.</li><li>since all above work only involves the lengths of the numbers, not the ranges themselves, they can be done upfront.</li><li>check whether the repets are in any of our ranges.</li></ol><p><a id=code-snippet--D02-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sympy</span> <span class=kn>import</span> <span class=n>divisors</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250202</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: Sum all repeated-pattern IDs (≥2 reps) in ranges.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Approach: generate all possible repeated-pattern numbers,
</span></span></span><span class=line><span class=cl><span class=s2>    then filter to those within any range. Much faster than
</span></span></span><span class=line><span class=cl><span class=s2>    checking every number when candidates are sparse.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    O(c * r) where c = candidates, r = ranges.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ranges</span> <span class=o>=</span> <span class=n>parse_2502</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Collect all digit lengths and their proper divisors</span>
</span></span><span class=line><span class=cl>    <span class=n>all_lens</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>for</span> <span class=n>rng</span> <span class=ow>in</span> <span class=n>ranges</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>rng</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>all_divs</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>l</span> <span class=ow>in</span> <span class=n>all_lens</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>all_divs</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=n>divisors</span><span class=p>(</span><span class=n>l</span><span class=p>)[:</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>  <span class=c1># exclude self</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Build bases for each divisor length</span>
</span></span><span class=line><span class=cl>    <span class=n>bases</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>f</span> <span class=ow>in</span> <span class=n>all_divs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>f</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span> <span class=n>bases</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>10</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span> <span class=n>bases</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=o>**</span><span class=p>(</span><span class=n>f</span><span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=mi>10</span><span class=o>**</span><span class=n>f</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Generate all candidate repeated-pattern numbers</span>
</span></span><span class=line><span class=cl>    <span class=n>candidates</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>div</span> <span class=ow>in</span> <span class=n>all_divs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>base</span> <span class=ow>in</span> <span class=n>bases</span><span class=p>[</span><span class=n>div</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>target_len</span> <span class=ow>in</span> <span class=n>all_lens</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>target_len</span> <span class=o>%</span> <span class=n>div</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>target_len</span> <span class=o>&gt;</span> <span class=n>div</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>candidates</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>base</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>target_len</span> <span class=o>//</span> <span class=n>div</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Sum candidates that fall in any range</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span> <span class=ow>in</span> <span class=n>ranges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>,</span> <span class=n>e</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>start</span><span class=p>),</span> <span class=nb>int</span><span class=p>(</span><span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>candidates</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>s</span> <span class=o>&lt;=</span> <span class=n>c</span> <span class=o>&lt;=</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>total</span> <span class=o>+=</span> <span class=n>c</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250202</span><span class=p>(</span><span class=n>D02</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>31898925685
</span></span></code></pre></td></tr></table></div></div><p>I think my solution is quite complicated.
I&rsquo;m not versed in regular expressions, this is one of my weak points.
In retrospect, since we are literally just finding patterns in a string, regex seems to be the natural choice. I plan to come back for a regex solution later.</p><h2 id=03-maximum-joltages-of-the-lobby-escalator>03 maximum joltages of the lobby escalator<a hidden class=anchor aria-hidden=true href=#03-maximum-joltages-of-the-lobby-escalator>#</a></h2><ol><li>we need to get the escalator working by setting it to a maximum power level;</li><li>we have a list of battery &ldquo;banks&rdquo;,</li><li>each bank in turn is another long list of labelled batteries, we can only choose a certain number of them;</li><li>the power that each bank supplies is given by concatenating the chosen numbers, e.g. choosing 5 and 6 from 45623 gives us 56;</li><li>for part 1 we choose 2 of them, for part 2 we choose 12.</li></ol><p>First parse the data into lists of integers.</p><p><a id=code-snippet--D03-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2503</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[[</span><span class=nb>int</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>l</span><span class=p>]</span> <span class=k>for</span> <span class=n>l</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D03</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>banks</span> <span class=o>=</span> <span class=n>parse_2503</span><span class=p>(</span><span class=n>D03</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>banks</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>banks</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span> <span class=nb>len</span><span class=p>(</span><span class=n>banks</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>200 100 100
</span></span></code></pre></td></tr></table></div></div><p>Part 1 looks quite simple: pick the best possible tens digit while leaving one digit for units, then after choosing the tens, choose the largest units digit to its right. It&rsquo;s all about indexing.</p><p><a id=code-snippet--D03-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250301</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: sum of maximum 2-digit joltage per bank.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>banks</span> <span class=o>=</span> <span class=n>parse_2503</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>banks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>tens</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>line</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>tens_idx</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>index</span><span class=p>(</span><span class=n>tens</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>units</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>line</span><span class=p>[</span><span class=n>tens_idx</span><span class=o>+</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>tens</span><span class=p>)</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>units</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250301</span><span class=p>(</span><span class=n>D03</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>17155
</span></span></code></pre></td></tr></table></div></div><p><code>line.index(val)</code> only finds the first index for <code>val</code>, which happens to be exactly what we want.</p><p>Part 2 is the same logic, but with 12 digits, we have to be more careful with the indexing. This is a typical case where the data being processed is changing as the loop progresses, so the most important issue is to keep the target data correctly updated. In this case, since the updated allowed data is a slice of the original list, we only have to keep updating the start and end of the indexing. The key is to always leaving enough room the the rest of the digits.</p><p><a id=code-snippet--D03-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250302</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: sum of maximum 12-digit joltage per bank.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>banks</span> <span class=o>=</span> <span class=n>parse_2503</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>banks</span><span class=p>:</span> <span class=c1># loop through each bank</span>
</span></span><span class=line><span class=cl>        <span class=n>start</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>12</span><span class=o>+</span><span class=mi>1</span> <span class=c1># allowed indexing range</span>
</span></span><span class=line><span class=cl>        <span class=n>picks</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>12</span><span class=p>):</span> <span class=c1># loop through the digits</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>end</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span> <span class=c1># the last digit requires separate slicing syntax</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span> <span class=o>=</span> <span class=n>line</span><span class=p>[</span><span class=n>start</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>                <span class=n>m</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span> <span class=c1># all digits except the last</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span> <span class=o>=</span> <span class=n>line</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>m</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>idx</span> <span class=o>=</span> <span class=n>l</span><span class=o>.</span><span class=n>index</span><span class=p>(</span><span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>start</span> <span class=o>+=</span> <span class=n>idx</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=n>end</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>picks</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=nb>int</span><span class=p>(</span><span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>str</span><span class=p>,</span> <span class=n>picks</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250302</span><span class=p>(</span><span class=n>D03</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>169685670469164
</span></span></code></pre></td></tr></table></div></div><p>All in all this one is fairly simple, but correctly updating the indices can be tricky if we kept it all in head. I found my current indexing approach rather ugly, especially the <code>-12+1</code> part, and the fact that I have to use a different indexing syntax for the last digit. Finding each digit is actually indexing a slice of the original list, so we have to accumulate the indices correctly. I had to draw some schematics on paper to get the indexing logic right. I intend to find a better indexing logic once I got the time.</p><h2 id=04-accessible-paper-rolls-in-the-print-shop>04 accessible paper rolls in the print shop<a hidden class=anchor aria-hidden=true href=#04-accessible-paper-rolls-in-the-print-shop>#</a></h2><ol><li>we have paper rolls in the print shop, arranged on a 2D grid;</li><li>rolls are denoted by <code>@</code>, empty spaces by <code>.</code>;</li><li>each roll has up to 8 neighbors (the 3x3 grid around it);</li><li>a roll is accessible if it has fewer than 4 neighboring rolls;</li><li>in part 1 we count all accessible rolls in the initial grid;</li><li>in part 2 we repeatedly remove all accessible rolls, and count how many are removed in total.</li></ol><p>Parsing the data into a 2D grid.</p><p><a id=code-snippet--D04-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2504</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse grid: @ -&gt; 1, . -&gt; 0.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[[</span><span class=mi>1</span> <span class=k>if</span> <span class=n>c</span> <span class=o>==</span> <span class=s1>&#39;@&#39;</span> <span class=k>else</span> <span class=mi>0</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>line</span><span class=p>]</span> <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D04</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>grid</span> <span class=o>=</span> <span class=n>parse_2504</span><span class=p>(</span><span class=n>D04</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>grid</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>135 135
</span></span></code></pre></td></tr></table></div></div><p>Initially I thought about using a tuple of indices for the data, but apparently using a 2D Numpy array would be much simpler. The key is the 3x3 kernel with a zero in the center.</p><p>This problem is quite similar to the convolution operation in computer vision, so I turned to <code>scipy.ndimage.convolve</code>. But actually the convolution used in computer vision packages, such as PyTorch, is not convolution, but correlation, since mathematically convolution involves flipping the input data first. So the right operation is actually <code>scipy.ndimage.correlate</code>, and padding all borders with 0 is natively supported with the <code>constant</code> mode, and the constant value being set to 0.</p><p>And then finding the targets satisfying the creterion is just filtering the results for paper rolls with less than 4 neighbors.</p><p><a id=code-snippet--D04-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scipy.ndimage</span> <span class=kn>import</span> <span class=n>correlate</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250401</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: count rolls with &lt;4 neighbors.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Uses 8-neighbor correlation with a 3x3 kernel.
</span></span></span><span class=line><span class=cl><span class=s2>    O(H*W) time, O(H*W) space.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>grid</span> <span class=o>=</span> <span class=n>parse_2504</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>grid</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>kernel</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>neighbor_counts</span> <span class=o>=</span> <span class=n>correlate</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>kernel</span><span class=p>,</span> <span class=n>mode</span><span class=o>=</span><span class=s1>&#39;constant&#39;</span><span class=p>,</span> <span class=n>cval</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>int</span><span class=p>(((</span><span class=n>arr</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>neighbor_counts</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>))</span><span class=o>.</span><span class=n>sum</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250401</span><span class=p>(</span><span class=n>D04</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>1437
</span></span></code></pre></td></tr></table></div></div><p>Part 2 is the same neighbor test, but applied repeatedly. Each pass removes the rolls that are currently accessible; we keep looping until no more rolls qualify.</p><p><a id=code-snippet--D04-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250402</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: iteratively remove accessible rolls and count total removed.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Each iteration is O(H*W); the number of iterations depends on structure.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>grid</span> <span class=o>=</span> <span class=n>parse_2504</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>grid</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>kernel</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>neighbor_counts</span> <span class=o>=</span> <span class=n>correlate</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>kernel</span><span class=p>,</span> <span class=n>mode</span><span class=o>=</span><span class=s1>&#39;constant&#39;</span><span class=p>,</span> <span class=n>cval</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>arr</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>neighbor_counts</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>mask</span><span class=o>.</span><span class=n>sum</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>mask</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=n>total</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250402</span><span class=p>(</span><span class=n>D04</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>8765
</span></span></code></pre></td></tr></table></div></div><p>I intend to implement the indexing solution later, without NumPy.
In retrospect the problem is quite easy, once we connected it to image processing in computer vision. But this doesn&rsquo;t come up right away; I only thought of it after spending quite some effort considering how to pad the grid. This shows that I still need practice on some of the basic algorithms.</p><h2 id=05-fresh-items-in-the-cafeteria>05 fresh items in the cafeteria<a hidden class=anchor aria-hidden=true href=#05-fresh-items-in-the-cafeteria>#</a></h2><ol><li>we are in the cafeteria, which keeps a LARGE inventory (large enough to feed a nation!)</li><li>we have two lists, the first is ranges of possible fresh items, possibly overlapping;</li><li>the second is the individual items that are currently actually in inventory, some fresh, some probably rotten;</li><li>for part 1 we need to find all the fresh items in inventory, and count them;</li><li>for part 2 we need to count how many items are actually in the overlapping fresh item ranges.</li></ol><p>My original plan was quite simplistic, just turn the lists of ranges into one big set with all the elements, which perfectly solves the partially overlapping problem; then part 1 is simply checking set membership, while part 2 is checking the size of the set. But set is atomic, which means that every element in it has to be independently initiated, and this requires a huge amount of memory: I tried and exhausted the memory before finishing the set initialization.</p><p>The cleanest practical solution should be deduplicating and merging the overlapping ranges, after ordering them one after another, and then for part 1 we can find the range corresponding to a certain item and check its membership, for part 2 just sum up the range lengths.</p><p><a id=code-snippet--D05-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2505</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>]],</span> <span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse input into (ranges, ids). Ranges are inclusive (lo, hi) tuples.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ranges</span><span class=p>,</span> <span class=n>ids</span> <span class=o>=</span> <span class=p>[</span><span class=n>part</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>part</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n\n</span><span class=s1>&#39;</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>ranges</span> <span class=o>=</span> <span class=p>[</span><span class=nb>tuple</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>rng</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;-&#39;</span><span class=p>)))</span> <span class=k>for</span> <span class=n>rng</span> <span class=ow>in</span> <span class=n>ranges</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>ids</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>ids</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ranges</span><span class=p>,</span> <span class=n>ids</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D05</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ranges</span><span class=p>,</span> <span class=n>ids</span> <span class=o>=</span> <span class=n>parse_2505</span><span class=p>(</span><span class=n>D05</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>ranges</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>ids</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>189 1000
</span></span></code></pre></td></tr></table></div></div><p>However for part 1, since we only have 1000 items, and 189 ranges to check, we might just check them one by one using brute force. Nonetheless, note that an item is fresh if it&rsquo;s in any range, so we could stop checking for that item once an enclosing range is found. And <code>any()</code> with a generator expression is quite neat for readable short-circuit membership testing.</p><p><a id=code-snippet--D05-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250501</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: Count IDs that fall within any range.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    O(n*m) where n=IDs, m=ranges.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ranges</span><span class=p>,</span> <span class=n>ids</span> <span class=o>=</span> <span class=n>parse_2505</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=nb>any</span><span class=p>(</span><span class=n>lo</span> <span class=o>&lt;=</span> <span class=n>inv</span> <span class=o>&lt;=</span> <span class=n>hi</span> <span class=k>for</span> <span class=n>lo</span><span class=p>,</span> <span class=n>hi</span> <span class=ow>in</span> <span class=n>ranges</span><span class=p>)</span> <span class=k>for</span> <span class=n>inv</span> <span class=ow>in</span> <span class=n>ids</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250501</span><span class=p>(</span><span class=n>D05</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>840
</span></span></code></pre></td></tr></table></div></div><p>Once data parsed to the correct format, the solution is just a one-liner. Using generators avoids keeping all the items in memory, and using <code>any</code> we can early stop the membership check once a match is found.</p><p>For part 2, saying that we need to deduplicate the ranges is neither clear on what the desired result should be like, nor how we could get there. We first need to sort them by starting value, which can be easily dealt with with <code>sorted</code>. Then starting with the first range, we can merge the remaining ranges to it, one by one. The merged result can be a single range, e.g. merging (1, 3) to (1,2) gives simply (1, 3), or a number of disjoint ranges, e.g. merging (4,6) to (1,3) gives [(1,3), (4,6)]. For this reason the starting object must be a list with only one element, not the element itself, i.e. <code>[(1,2),]</code> not <code>(1,2)</code>.</p><p>My initial impression of <code>reduce</code> is largely limited to summary statistics, min, max, argmin, etc. But <code>reduce</code> is actually a general procedure that applies a function of two arguments cumulatively to the items of a sequence or iterable, from left to right, so as to reduce the iterable to a single value. So it&rsquo;s a perfect fit for what we are trying to achieve.</p><p><a id=code-snippet--D05-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250502</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: Count total unique IDs covered by union of all ranges.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Classic interval merging algorithm:
</span></span></span><span class=line><span class=cl><span class=s2>    1. Sort ranges by start
</span></span></span><span class=line><span class=cl><span class=s2>    2. Merge overlapping/adjacent ranges via reduce
</span></span></span><span class=line><span class=cl><span class=s2>    3. Sum lengths (+1 for inclusive bounds)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ranges</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>parse_2505</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sorted_ranges</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>ranges</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>merge_step</span><span class=p>(</span><span class=n>acc</span><span class=p>,</span> <span class=n>rng</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>last_start</span><span class=p>,</span> <span class=n>last_end</span> <span class=o>=</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>next_start</span><span class=p>,</span> <span class=n>next_end</span> <span class=o>=</span> <span class=n>rng</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>last_end</span> <span class=o>&lt;</span> <span class=n>next_start</span><span class=p>:</span>  <span class=c1># no overlap</span>
</span></span><span class=line><span class=cl>            <span class=n>acc</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>rng</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>  <span class=c1># overlap: extend current range</span>
</span></span><span class=line><span class=cl>            <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>last_start</span><span class=p>,</span> <span class=nb>max</span><span class=p>(</span><span class=n>last_end</span><span class=p>,</span> <span class=n>next_end</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>acc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>merged</span> <span class=o>=</span> <span class=n>reduce</span><span class=p>(</span><span class=n>merge_step</span><span class=p>,</span> <span class=n>sorted_ranges</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>sorted_ranges</span><span class=p>[:</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>hi</span> <span class=o>-</span> <span class=n>lo</span> <span class=o>+</span> <span class=mi>1</span> <span class=k>for</span> <span class=n>lo</span><span class=p>,</span> <span class=n>hi</span> <span class=ow>in</span> <span class=n>merged</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250502</span><span class=p>(</span><span class=n>D05</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>359913027576322
</span></span></code></pre></td></tr></table></div></div><p>The use of <code>reduce</code> in this puzzle is inspirational to me. More and more I&rsquo;m convinced that programming is simply about iteration, once we have the object to be iterated over, and the target to be produced correctly configured (that is, the data structure properly laied out.) All other procedural programs are boilerplates. So again, &ldquo;a program without a loop and a structured variable is not worth writing&rdquo;.</p><h2 id=06-cephalopod-math-in-the-trash-compactor>06 cephalopod math in the trash compactor<a hidden class=anchor aria-hidden=true href=#06-cephalopod-math-in-the-trash-compactor>#</a></h2><ol><li>we are given a set of arithmetic problems laid out in a wide grid;</li><li>the last row has the operators, the rows above are digits for operands;</li><li>problems are separated by full columns of spaces;</li><li>part 1 reads numbers by rows (split on whitespace), part 2 reads numbers by columns (trimming the leading or ending whitespaces);</li><li>once parsed, each problem is just a sum or a product, then we add all results.</li></ol><p>This is the first time where the difficulty of solving the puzzle lays in parsing the data, rather than solving the problems. There are only 2 operators, multiplication and addition, which should not pose any problem in any modern programming language.
In fact, after parsing the data correctly the solution for both parts should be identical.</p><p>For part 1 the key problem is to split the numbers into groups of problems. This seemingly simple problem is complicated by the fact that all data processing functions I know of (in Python) all process data row by row, while the numbers for each problem are arranged by columns.
However this is made easy by a combination of <code>zip(*numbers)</code>, which is effectively the transpose function in standard Python. The operator row gives the operator for each problem.</p><p><a id=code-snippet--D06-parse01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_250601</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>]],</span> <span class=nb>list</span><span class=p>[</span><span class=nb>str</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1 parse: split each row on whitespace, then zip into problems.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>number_rows</span><span class=p>,</span> <span class=n>operator_row</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>row</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>number_rows</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>problems</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>numbers</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>operators</span> <span class=o>=</span> <span class=n>operator_row</span><span class=o>.</span><span class=n>split</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>problems</span><span class=p>,</span> <span class=n>operators</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D06</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>problems</span><span class=p>,</span> <span class=n>operators</span> <span class=o>=</span> <span class=n>parse_250601</span><span class=p>(</span><span class=n>D06</span><span class=o>.</span><span class=n>examples</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>problems</span><span class=p>),</span> <span class=n>problems</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>operators</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>4 (123, 45, 6) *
</span></span></code></pre></td></tr></table></div></div><p>After parsing the data all that&rsquo;s left is to compute each problem using its operator and sum everything. Since this exact logic can be used in both parts, I&rsquo;ve refactored the solver function so that in addition to the data, it also accepts a parser argument.</p><p><a id=code-snippet--D06-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>prod</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_2506</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>parser</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Shared solver: apply the operator to each problem, then sum.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>problems</span><span class=p>,</span> <span class=n>operators</span> <span class=o>=</span> <span class=n>parser</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>prod</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=k>if</span> <span class=n>op</span> <span class=o>==</span> <span class=s1>&#39;*&#39;</span> <span class=k>else</span> <span class=nb>sum</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>nums</span><span class=p>,</span> <span class=n>op</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>problems</span><span class=p>,</span> <span class=n>operators</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_2506</span><span class=p>(</span><span class=n>D06</span><span class=o>.</span><span class=n>input_data</span><span class=p>,</span> <span class=n>parse_250601</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>6957525317641
</span></span></code></pre></td></tr></table></div></div><p>Actually we can understand this solution as another parser: parsing the <code>*</code> and <code>+</code> symbols into Python <code>prod</code> and <code>sum</code> functions. But this is rather simple. I plan to study some similar use cases but with more complexity later (Norvig&rsquo;s lisp interpreters).</p><p>The parsing logic for part 2 is a bit more convoluted. The problems in part 1 are stored in different columns, and we have to process them into rows (thus the need for transpose), because that&rsquo;s what our computer is accustomed to process.
In part 2, apart from the problems being separated in columns, the operands for each problem are also in columns, so this creates an extra layer of complexity.
We can see that most of the difficulty in this puzzle arises because of the fact that we are only accustomed to processing information in a certain fashion, i.e. one row after another.
It&rsquo;s curious that we are so used to processing information row by row, from left to right, and almost all our computer tools are built around this procedure.
It&rsquo;s quite possible that some other civilizations might invent some other procedures that work differently.
Classic Chinese, for example, reads column by column, and from right to left.</p><p>Back to the problem, the key is to transpose the character grid, then group contiguous non-blank columns into problems.</p><p><a id=code-snippet--D06-parse02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>groupby</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_250602</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>]],</span> <span class=nb>list</span><span class=p>[</span><span class=nb>str</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2 parse: read numbers by columns (character-wise).&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>number_rows</span><span class=p>,</span> <span class=n>operator_row</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>columns</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>chars</span><span class=p>)</span> <span class=k>for</span> <span class=n>chars</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>number_rows</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>groups</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=nb>list</span><span class=p>(</span><span class=n>group</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>is_digit</span><span class=p>,</span> <span class=n>group</span> <span class=ow>in</span> <span class=n>groupby</span><span class=p>(</span><span class=n>columns</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>col</span><span class=p>:</span> <span class=n>col</span><span class=o>.</span><span class=n>strip</span><span class=p>()</span> <span class=o>!=</span> <span class=s1>&#39;&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_digit</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>problems</span> <span class=o>=</span> <span class=p>[</span><span class=nb>tuple</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>col</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span> <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=n>group</span><span class=p>)</span> <span class=k>for</span> <span class=n>group</span> <span class=ow>in</span> <span class=n>groups</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>operators</span> <span class=o>=</span> <span class=n>operator_row</span><span class=o>.</span><span class=n>split</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>problems</span><span class=p>,</span> <span class=n>operators</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>problems</span><span class=p>,</span> <span class=n>operators</span> <span class=o>=</span> <span class=n>parse_250602</span><span class=p>(</span><span class=n>D06</span><span class=o>.</span><span class=n>examples</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>problems</span><span class=p>),</span> <span class=n>problems</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>operators</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>4 (1, 24, 356) *
</span></span></code></pre></td></tr></table></div></div><p>The main novelty here is <code>itertools.groupby</code>, which separates the individual columns into problem groups, by detecting columns that are all whitespaces.</p><p><a id=code-snippet--D06-02-solve></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_2506</span><span class=p>(</span><span class=n>D06</span><span class=o>.</span><span class=n>input_data</span><span class=p>,</span> <span class=n>parse_250602</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>13215665360076
</span></span></code></pre></td></tr></table></div></div><p><code>zip(*list)</code> and <code>itertools.groupby</code> are the new weapons in the arsenal!</p><h2 id=07-splitting-beams-in-the-lab-tachyon-manifolds>07 splitting beams in the lab Tachyon manifolds<a hidden class=anchor aria-hidden=true href=#07-splitting-beams-in-the-lab-tachyon-manifolds>#</a></h2><ol><li>we are in a Tachyon manifold, which is simply a 2D grid field;</li><li>there is (only) one beam of light passing through the field;</li><li>the beam passes straight through if there is no hindrance, and splits to left and right if encountering a splitter;</li><li>part 1 needs to count how many splitters have been hit on;</li><li>part 2 needs to count how many individual paths the beam passe through.</li></ol><p>Since we need to get the indices of the beams and the splitters, we can parse the data using list comprehension with enumeration. This keep the indices whose values meet a certain creterion. And we can discard the splitter rows that don&rsquo;t actually have splitters.</p><p><a id=code-snippet--D07-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2507</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=nb>list</span><span class=p>[</span><span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>]]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse manifold into start column and splitter rows.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>lines</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=p>{</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>ch</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>lines</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=k>if</span> <span class=n>ch</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>splitter_rows</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>ch</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>line</span><span class=p>)</span> <span class=k>if</span> <span class=n>ch</span> <span class=o>==</span> <span class=s1>&#39;^&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>lines</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>splitter_rows</span> <span class=o>=</span> <span class=p>[</span><span class=n>s</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>splitter_rows</span> <span class=k>if</span> <span class=n>s</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>start</span><span class=p>,</span> <span class=n>splitter_rows</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D07</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>lines</span> <span class=o>=</span> <span class=n>D07</span><span class=o>.</span><span class=n>input_data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>start</span><span class=p>,</span> <span class=n>splitter_rows</span> <span class=o>=</span> <span class=n>parse_2507</span><span class=p>(</span><span class=n>D07</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>lines</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>lines</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>splitter_rows</span><span class=p>),</span> <span class=nb>sum</span><span class=p>(</span><span class=n>line</span><span class=o>.</span><span class=n>count</span><span class=p>(</span><span class=s1>&#39;^&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>lines</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>142 141
</span></span><span class=line><span class=cl>70 1650
</span></span></code></pre></td></tr></table></div></div><p>For part 1, a splitter is activated only if:</p><ol><li>there is a splitter in the first place;</li><li>a beam is present in the previous row.</li></ol><p>So this check can be done by comparing the existence of beams in one row, with the existence of splitters in the next row, and this can be done elegantly with set operations. Concretely, A-B are kept as is, and B-A updated with shifts, then we take the union of the two to pass to the next step.</p><p><a id=code-snippet--D07-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>step_beams</span><span class=p>(</span><span class=n>beams</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>splitters</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Advance beams through one splitter row and count activations.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>hits</span> <span class=o>=</span> <span class=n>beams</span> <span class=o>&amp;</span> <span class=n>splitters</span>
</span></span><span class=line><span class=cl>    <span class=n>misses</span> <span class=o>=</span> <span class=n>beams</span> <span class=o>-</span> <span class=n>splitters</span>
</span></span><span class=line><span class=cl>    <span class=n>spawned</span> <span class=o>=</span> <span class=p>{</span><span class=n>col</span> <span class=o>+</span> <span class=n>d</span> <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=n>hits</span> <span class=k>for</span> <span class=n>d</span> <span class=ow>in</span> <span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>misses</span> <span class=o>|</span> <span class=n>spawned</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>hits</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250701</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: count activated splitters.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    O(sum(len(beams) + len(splitters))) across rows.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>beams</span><span class=p>,</span> <span class=n>splitter_rows</span> <span class=o>=</span> <span class=n>parse_2507</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>splitters</span> <span class=ow>in</span> <span class=n>splitter_rows</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>beams</span><span class=p>,</span> <span class=n>activations</span> <span class=o>=</span> <span class=n>step_beams</span><span class=p>(</span><span class=n>beams</span><span class=p>,</span> <span class=n>splitters</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=n>activations</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250701</span><span class=p>(</span><span class=n>D07</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>1524
</span></span></code></pre></td></tr></table></div></div><p>I haven&rsquo;t used the set operations before, so this has been a useful exercise.</p><p>For part 2, we need to count the number of distinct paths (timelines) the beam took. My original solution was to store the complete path trajectories, but it turned out to be too memory intensive. Then it occurred to me that we only need to <strong>count</strong> the number of paths, not trace all of them. This is a big difference, since counting them only requires some summary statistics of the paths, not the paths themselves. In fact, at each step in the manifold, we can count the total spawned paths by counting how many end points there are, and how many distinct paths pass through each ending point. And this info can easily be stored in a dict.</p><p><a id=code-snippet--D07-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>step_counts</span><span class=p>(</span><span class=n>paths</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span> <span class=n>splitters</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Advance all timeline counts through one splitter row.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>new_paths</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>col</span><span class=p>,</span> <span class=n>count</span> <span class=ow>in</span> <span class=n>paths</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>col</span> <span class=ow>in</span> <span class=n>splitters</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>ncol</span> <span class=ow>in</span> <span class=p>(</span><span class=n>col</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>col</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>new_paths</span><span class=p>[</span><span class=n>ncol</span><span class=p>]</span> <span class=o>=</span> <span class=n>new_paths</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>ncol</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>new_paths</span><span class=p>[</span><span class=n>col</span><span class=p>]</span> <span class=o>=</span> <span class=n>new_paths</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>col</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>new_paths</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250702</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: count timelines after all splits.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    O(sum(len(paths) + len(splitters))) across rows.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>beams</span><span class=p>,</span> <span class=n>splitter_rows</span> <span class=o>=</span> <span class=n>parse_2507</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>paths</span> <span class=o>=</span> <span class=p>{</span><span class=n>col</span><span class=p>:</span> <span class=mi>1</span> <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=n>beams</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>splitters</span> <span class=ow>in</span> <span class=n>splitter_rows</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># print(paths)</span>
</span></span><span class=line><span class=cl>        <span class=n>paths</span> <span class=o>=</span> <span class=n>step_counts</span><span class=p>(</span><span class=n>paths</span><span class=p>,</span> <span class=n>splitters</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>paths</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250702</span><span class=p>(</span><span class=n>D07</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>32982105837605
</span></span></code></pre></td></tr></table></div></div><p>I had originally had some trouble updating the paths dict, because with splitting beams we have to asign values to keys that doesn&rsquo;t yet exist. But of course such a common scenario is already covered by an existing dict method <code>dict.get(key, default)</code>, which returns the corresponding value is the key exists, and returns a default value otherwise.</p><p>Incidentally today&rsquo;s puzzle has some terminologies that I don&rsquo;t know, like Tachyon manifolds, and some connections that I&rsquo;m not aware of, like quantum fields. Nevertheless this does not in anyway interferes with solving the puzzle. This is a common pattern in computer science, or more specifically algorithm design. A specific problem from a specific domain can be narrated in a specific domain language, but all those specificity can often be abstracted away when devising the algorithm and solving the problem.
However this is not saying all the specificities do not matter: on the contrary, simply running a computer program to get an answer is useless, if we can&rsquo;t apply it back to the specific problems.</p><h2 id=08-connecting-junction-boxes-in-the-playground>08 connecting junction boxes in the playground<a hidden class=anchor aria-hidden=true href=#08-connecting-junction-boxes-in-the-playground>#</a></h2><ol><li>We are in a playground with junction boxes, each with a unique 3D coordinate.</li><li>We repeatedly connect the closest <strong>pairs</strong> of boxes (by straight-line distance), creating connected groups.</li><li>For part 1, we process the first 1000 closest pairs (even if some are already connected), then multiply the sizes of the three largest circuits.</li><li>For part 2, we keep processing closest pairs until all boxes are in one group; then multiply the x coordinates of the last pair that merges the final two circuits.</li></ol><p>A subtle but important point that confused me in the beginning: the problem says &ldquo;closest <strong>pairs</strong>&rdquo;, not &ldquo;successful merges.&rdquo; In the example, after &ldquo;ten shortest connections&rdquo; only nine merges happen because one pair was already in the same circuit. So we must process the pairs in order, allowing no-ops.</p><p>We need to connect individual nodes into separate graphs. The key issues to solve include: 1, which nodes to connect; 2, how to connect; 3, what information to extract from the connected nodes. After figuring out which nodes to connect, which simply calculates the paired distances and rank them, the key problem is graph manipulation.
The right abstraction here is Union-Find (disjoint set union). Union, on surface, is connecting two nodes, but in reality it&rsquo;s connecting the roots of the two nodes, and for this reason we need to know which circuit each box belongs to, and the sizes of those circuits; the actual edges are irrelevant.</p><p><a id=code-snippet--D08-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2508</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse coordinates from &#39;x,y,z&#39; lines.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=nb>tuple</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;,&#39;</span><span class=p>)))</span> <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D08</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>points</span> <span class=o>=</span> <span class=n>parse_2508</span><span class=p>(</span><span class=n>D08</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>points</span><span class=p>),</span> <span class=n>points</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>1000 (54996, 20819, 75067)
</span></span></code></pre></td></tr></table></div></div><p>Getting the sorted distance together with the corresponding indices is easy. The distances are used for sorting, while the indices are used later to guide which points to connect, in which order.</p><p><a id=code-snippet--D08-sort-distance></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>combinations</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sorted_pairs_2508</span><span class=p>(</span><span class=n>points</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>]])</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Return (dist2, i, j) for all pairs, sorted by dist2.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    dist2 is squared Euclidean distance (ordering is unchanged).
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>pairs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>combinations</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>points</span><span class=p>)),</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>,</span> <span class=n>z1</span> <span class=o>=</span> <span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>,</span> <span class=n>z2</span> <span class=o>=</span> <span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>d2</span> <span class=o>=</span> <span class=p>(</span><span class=n>x1</span> <span class=o>-</span> <span class=n>x2</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span> <span class=o>+</span> <span class=p>(</span><span class=n>y1</span> <span class=o>-</span> <span class=n>y2</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span> <span class=o>+</span> <span class=p>(</span><span class=n>z1</span> <span class=o>-</span> <span class=n>z2</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=n>pairs</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>d2</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>pairs</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>The key is the union-find algorithm. Each node is initiated as an independent group, of size 1, with itself as its parent. <code>find</code> traces a graph to its root, it follows parents and compresses the path so future lookups are faster. <code>union</code> merges two roots, updates the size of the new root, and decrements <code>components</code>. We use <code>group_sizes</code> to read off the sizes of all current circuits.</p><p><a id=code-snippet--D08-uf></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>UnionFind</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Disjoint set union with path compression.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    We keep it simple: always attach one root under the other.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>components</span> <span class=o>=</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>!=</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;Merge sets containing x and y. Return True if a merge happened.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>rx</span><span class=p>,</span> <span class=n>ry</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>rx</span> <span class=o>==</span> <span class=n>ry</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>ry</span><span class=p>]</span> <span class=o>=</span> <span class=n>rx</span> <span class=c1># simply attanch the second group to the first</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>rx</span><span class=p>]</span> <span class=o>+=</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>ry</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>components</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>group_sizes</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>))</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>sorted</span><span class=p>(</span><span class=n>uf</span><span class=o>.</span><span class=n>group_sizes</span><span class=p>(),</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>),</span> <span class=n>uf</span><span class=o>.</span><span class=n>components</span><span class=p>)</span>  <span class=c1># [2, 2, 1], 3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># merges the {0,1} and {2,3} circuits</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>sorted</span><span class=p>(</span><span class=n>uf</span><span class=o>.</span><span class=n>group_sizes</span><span class=p>(),</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>),</span> <span class=n>uf</span><span class=o>.</span><span class=n>components</span><span class=p>)</span>  <span class=c1># [4, 1], 2</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[2, 2, 1] 3
</span></span><span class=line><span class=cl>[4, 1] 2
</span></span></code></pre></td></tr></table></div></div><p>For part 1, process the first 1000 closest pairs, then take the top three circuit sizes.</p><p><a id=code-snippet--D08-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>prod</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250801</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: product of sizes of the three largest circuits.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    O(n^2 log n) time for sorting all pairs, O(n^2) space.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>points</span> <span class=o>=</span> <span class=n>parse_2508</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>pairs</span> <span class=o>=</span> <span class=n>sorted_pairs_2508</span><span class=p>(</span><span class=n>points</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>points</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>pairs</span><span class=p>[:</span><span class=mi>1000</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sizes</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>uf</span><span class=o>.</span><span class=n>group_sizes</span><span class=p>(),</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>prod</span><span class=p>(</span><span class=n>sizes</span><span class=p>[:</span><span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250801</span><span class=p>(</span><span class=n>D08</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>112230
</span></span></code></pre></td></tr></table></div></div><p>Part 2 only changes the stopping condition: keep processing closest pairs until there&rsquo;s a single circuit, and return the product of the x-coordinates of the last <strong>successful</strong> merge.</p><p><a id=code-snippet--D08-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250802</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: product of x-coordinates from the last merging pair.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    O(n^2 log n) time for sorting all pairs, O(n^2) space.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>points</span> <span class=o>=</span> <span class=n>parse_2508</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>pairs</span> <span class=o>=</span> <span class=n>sorted_pairs_2508</span><span class=p>(</span><span class=n>points</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>points</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>pairs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=ow>and</span> <span class=n>uf</span><span class=o>.</span><span class=n>components</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250802</span><span class=p>(</span><span class=n>D08</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>2573952864
</span></span></code></pre></td></tr></table></div></div><p>It is actually quite difficult to get the right level of abstraction. I wandered about for quite a while till it&rsquo;s clear that the union-find algorithm should only operate on the indices; and all of the indice operations, with memory, should be included. However, everything else, including the distances and the ranked pair of indices, should NOT be part of this abstraction. This is evident from the fact that the <code>UnionFind</code> class is initiated with only the #nodes and nothing else. This might feel obvious in retrospect, but leaky abstractions caused me a lot of headache before I came up to the right abstraction.</p><p>Once Union-Find is in place, part 2 just change the stopping rule.</p><h2 id=09-rectangular-tile-patterns-in-the-movie-theatre>09 rectangular tile patterns in the movie theatre<a hidden class=anchor aria-hidden=true href=#09-rectangular-tile-patterns-in-the-movie-theatre>#</a></h2><ol><li>We are now in the movie theatre, and we are to redecorate the floor, which is covered in tiles of various colors.</li><li>There are red tiles; between consecutive red tiles there are green tiles; and the interior enclosed by the red/green loop is also green.</li><li>For part 1, we choose two red tiles as opposite corners of a rectangle and want the maximum area.</li><li>For part 2, we still want the maximum area, but with the extra requirement that the rectangle must lie entirely on red or green tiles.</li></ol><p>Parsing the data is trivial.</p><p><a id=code-snippet--D09-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2509</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse red tile coordinates as (x, y) pairs.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=nb>tuple</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;,&#39;</span><span class=p>)))</span> <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D09</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>9</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>red</span> <span class=o>=</span> <span class=n>parse_2509</span><span class=p>(</span><span class=n>D09</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>red</span><span class=p>),</span> <span class=n>red</span><span class=p>[:</span><span class=mi>3</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>496 [(98026, 50027), (98026, 51253), (98365, 51253)]
</span></span></code></pre></td></tr></table></div></div><p>Part 1 is simple. With less than 500 points, try every pair of red tiles as opposite corners is computationally quite feasible.</p><p><a id=code-snippet--D09-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>combinations</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250901</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: maximum rectangle area from two red corners.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    O(n^2) time, O(1) extra space.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>red</span> <span class=o>=</span> <span class=n>parse_2509</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>abs</span><span class=p>(</span><span class=n>x2</span> <span class=o>-</span> <span class=n>x1</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=nb>abs</span><span class=p>(</span><span class=n>y2</span> <span class=o>-</span> <span class=n>y1</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>),</span> <span class=p>(</span><span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>)</span> <span class=ow>in</span> <span class=n>combinations</span><span class=p>(</span><span class=n>red</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250901</span><span class=p>(</span><span class=n>D09</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>4750297200
</span></span></code></pre></td></tr></table></div></div><p>The only thing worth taking note of is how the area is calculated. The red tiles are squares with areas themselves, not just points (which have no area), and thus the <code>+1</code> in the formula.</p><p>Part 2 is the real problem of the day. We can still iterate over all pairs of opposite corners, but then we need to check all tiles of the resulting rectangle is in the red-green encircled area. This entails several problems:</p><ol><li>what this enclosed area is actually like. This is actually a problem for part 1, but with part 1 being so easy we didn&rsquo;t even bother to deal with it.</li><li>how to check if a point is in the enclosed area. This is the core problem.</li><li>which points we have to check for such enclosion.</li></ol><p>The enclosed area turns out to be a rectilinear polygon, but I only figured it out after quite some data explorations, including the term rectilinear itself.
And to check for enclosion there is a well established algorithm called ray casting, but I know nothing about it.
Besides, we are now in a (100K, 100K) area, each rectangle thus has a vast area, so there are a HUGE amount of points to check (if we avoid being clever), the computation has increased immensely.</p><p>I tried to implement the ray casting algorithm, but got buried in the implementation details and edge cases, and I got stuck on the problem for a whole week. Finally I reworked the puzzle after having finished day 10 and 11, and simply used an existing package, <code>shapely</code>, which has established and well polished methods for all 3 issues. So in the end I solved the problem by not solving it.</p><p><a id=code-snippet--D09-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>shapely.geometry</span> <span class=kn>import</span> <span class=n>Polygon</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>shapely.prepared</span> <span class=kn>import</span> <span class=n>prep</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_250902</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: maximum rectangle area fully covered by red/green tiles.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Uses shapely for containment checks (non-stdlib).
</span></span></span><span class=line><span class=cl><span class=s2>    O(n^2) rectangle checks; containment is fast with a prepared polygon.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>red</span> <span class=o>=</span> <span class=n>parse_2509</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>poly</span> <span class=o>=</span> <span class=n>Polygon</span><span class=p>(</span><span class=n>red</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>prepared</span> <span class=o>=</span> <span class=n>prep</span><span class=p>(</span><span class=n>poly</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>best</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>),</span> <span class=p>(</span><span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>)</span> <span class=ow>in</span> <span class=n>combinations</span><span class=p>(</span><span class=n>red</span><span class=p>,</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>xmin</span><span class=p>,</span> <span class=n>xmax</span> <span class=o>=</span> <span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=n>x2</span><span class=p>)</span> <span class=k>if</span> <span class=n>x1</span> <span class=o>&lt;=</span> <span class=n>x2</span> <span class=k>else</span> <span class=p>(</span><span class=n>x2</span><span class=p>,</span> <span class=n>x1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ymin</span><span class=p>,</span> <span class=n>ymax</span> <span class=o>=</span> <span class=p>(</span><span class=n>y1</span><span class=p>,</span> <span class=n>y2</span><span class=p>)</span> <span class=k>if</span> <span class=n>y1</span> <span class=o>&lt;=</span> <span class=n>y2</span> <span class=k>else</span> <span class=p>(</span><span class=n>y2</span><span class=p>,</span> <span class=n>y1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>rect</span> <span class=o>=</span> <span class=n>Polygon</span><span class=p>([(</span><span class=n>xmin</span><span class=p>,</span> <span class=n>ymin</span><span class=p>),</span> <span class=p>(</span><span class=n>xmin</span><span class=p>,</span> <span class=n>ymax</span><span class=p>),</span> <span class=p>(</span><span class=n>xmax</span><span class=p>,</span> <span class=n>ymax</span><span class=p>),</span> <span class=p>(</span><span class=n>xmax</span><span class=p>,</span> <span class=n>ymin</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>prepared</span><span class=o>.</span><span class=n>covers</span><span class=p>(</span><span class=n>rect</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>area</span> <span class=o>=</span> <span class=p>(</span><span class=n>xmax</span> <span class=o>-</span> <span class=n>xmin</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>ymax</span> <span class=o>-</span> <span class=n>ymin</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>area</span> <span class=o>&gt;</span> <span class=n>best</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best</span> <span class=o>=</span> <span class=n>area</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_250902</span><span class=p>(</span><span class=n>D09</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>1578115935
</span></span></code></pre></td></tr></table></div></div><p>I still need to come back and figure out how to implement the algorithm properly. I tried to look into the <code>shapely</code> implementations, but they are buried in optimized code God knows where. This remains the biggest challange of AOC 2025 for me, and the only case that I considered a failure.</p><p>There is one solution, which I stumbled upon in the forums, that is a data-compression first approach. This starts by noticing that while the area is large (100K times 100K), we only have less than 500 points, which means that there must by many in-the-middle points that we don&rsquo;t really have to check. The idea is to do a coordinate compression first, finding out which points in the 100K field actually matters (are the edges and corners), solve the problem on this compressed grid first, and then project back to the original grid to find the areas. The reduced grid being small enough, that we might be able to just brute-force through it. While I still don&rsquo;t know how to solve it exactly, this is a brilliant approach to simplify the problem, and I intend to try it later.</p><h2 id=10-combining-machine-switches-in-the-factory>10 combining machine switches in the factory<a hidden class=anchor aria-hidden=true href=#10-combining-machine-switches-in-the-factory>#</a></h2><ol><li>We are in the factory, which has a big amount of machines and yet none of them are working.</li><li>Each machine has N indicator lights, N joltage levels, and M switches;</li><li>The switches can manipulate both the lights and the joltages;</li><li>Part 1: find the minimum number of button presses to reach the target on/off pattern; multiple presses of the same buton cancels out.</li><li>Part 2: ignore the lights and use the same switches to increment counters to target joltage values; now presses are nonnegative integers.</li></ol><p>For this one, I&rsquo;m quite proud of myself, for being able to carefully comb through the word soup and parse it to clear matrix multiplication operations and optimization problems.
Both parts use the same data format, just different variables, so when refactoring I combined them together with a boolean switch.
We have till now mostly parsed data with <code>splitlines</code> or <code>split</code>, but for more complex data patterns we need regular expressions.</p><p><a id=code-snippet--D10-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2510</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>use_joltage</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Return list of (y, XT) where y is target, XT is N x M toggle matrix.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>parsed</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>use_joltage</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>target</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\{([0-9,]+)\}&#39;</span><span class=p>,</span> <span class=n>line</span><span class=p>)</span><span class=o>.</span><span class=n>group</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>target</span> <span class=o>=</span> <span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>target</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;,&#39;</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>diagram</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\[([.#]+)\]&#39;</span><span class=p>,</span> <span class=n>line</span><span class=p>)</span><span class=o>.</span><span class=n>group</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>target</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span> <span class=k>if</span> <span class=n>c</span> <span class=o>==</span> <span class=s1>&#39;#&#39;</span> <span class=k>else</span> <span class=mi>0</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>diagram</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>switches</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\(([0-9,]+)\)&#39;</span><span class=p>,</span> <span class=n>line</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>indices_list</span> <span class=o>=</span> <span class=p>[[</span><span class=nb>int</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>sw</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;,&#39;</span><span class=p>)]</span> <span class=k>for</span> <span class=n>sw</span> <span class=ow>in</span> <span class=n>switches</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>N</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>target</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>M</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>indices_list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>X</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>M</span><span class=p>,</span> <span class=n>N</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>inds</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>indices_list</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>X</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>inds</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>)</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>parsed</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>y</span><span class=p>,</span> <span class=n>X</span><span class=o>.</span><span class=n>T</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>parsed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D10</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ex</span> <span class=o>=</span> <span class=n>D10</span><span class=o>.</span><span class=n>examples</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>input_data</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=n>D10</span><span class=o>.</span><span class=n>input_data</span>
</span></span></code></pre></td></tr></table></div></div><p>For part 1 we resorted to brute force exhaustive search, but with early stopping. This is feasible, firstly because the number of switches for each machine is limited. But more importantly because pressing the same switches twice cancels out, we should either press a button, or don&rsquo;t; the search space for each switch is thus just {0, 1}, so we have a closed exploration space.</p><p>Since we aim to find the minimum number of presses, we search by the number of presses, starting from 1, and early stop once a matching combination is found.</p><p><a id=code-snippet--D10-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>combinations</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>comb</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>construct_ws</span><span class=p>(</span><span class=n>M</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>m</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Create [M, C(M,m)] matrix of switch vectors with exactly m presses.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>K</span> <span class=o>=</span> <span class=n>comb</span><span class=p>(</span><span class=n>M</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ws</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>M</span><span class=p>,</span> <span class=n>K</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>combo</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>combinations</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>M</span><span class=p>),</span> <span class=n>m</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>ws</span><span class=p>[</span><span class=nb>list</span><span class=p>(</span><span class=n>combo</span><span class=p>),</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ws</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_251001</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: minimum presses to match lights (mod 2).
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Uses NumPy for matrix multiplication (non-stdlib).
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>parsed</span> <span class=o>=</span> <span class=n>parse_2510</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>use_joltage</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>y</span><span class=p>,</span> <span class=n>XT</span> <span class=ow>in</span> <span class=n>parsed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>_</span><span class=p>,</span> <span class=n>M</span> <span class=o>=</span> <span class=n>XT</span><span class=o>.</span><span class=n>shape</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>m</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>M</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>ws</span> <span class=o>=</span> <span class=n>construct_ws</span><span class=p>(</span><span class=n>M</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>ys</span> <span class=o>=</span> <span class=p>(</span><span class=n>XT</span> <span class=o>@</span> <span class=n>ws</span><span class=p>)</span> <span class=o>%</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>all</span><span class=p>(</span><span class=n>ys</span> <span class=o>==</span> <span class=n>y</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>                <span class=n>total</span> <span class=o>+=</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_251001</span><span class=p>(</span><span class=n>data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>542
</span></span></code></pre></td></tr></table></div></div><p>The same method won&rsquo;t work on part 2. Now the targets are positive integers, and each press increases the counter, so the search space is now infinite, which renders exhaustive search pointless. However by formulating the problem as minimizing sum(w) subject to XT @ w = y and w >= 0, it becomes an standard integer linear programming problem, and I simply used SciPy&rsquo;s <code>linprog</code> with <code>integrality=1</code>.</p><p><a id=code-snippet--D10-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scipy.optimize</span> <span class=kn>import</span> <span class=n>linprog</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_251002</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: minimum presses to match joltage counters (ILP).
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Uses SciPy linprog with integrality=1.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>parsed</span> <span class=o>=</span> <span class=n>parse_2510</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>use_joltage</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>y</span><span class=p>,</span> <span class=n>XT</span> <span class=ow>in</span> <span class=n>parsed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>M</span> <span class=o>=</span> <span class=n>XT</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>=</span> <span class=n>linprog</span><span class=p>(</span><span class=n>c</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>M</span><span class=p>,</span> <span class=n>A_eq</span><span class=o>=</span><span class=n>XT</span><span class=p>,</span> <span class=n>b_eq</span><span class=o>=</span><span class=n>y</span><span class=o>.</span><span class=n>ravel</span><span class=p>(),</span> <span class=n>integrality</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>round</span><span class=p>(</span><span class=n>res</span><span class=o>.</span><span class=n>fun</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_251002</span><span class=p>(</span><span class=n>data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>20871
</span></span></code></pre></td></tr></table></div></div><p>I still don&rsquo;t quite understand why it works, but with some trial and error on some example problems I&rsquo;ve managed to make it work. I&rsquo;m always interested in how linear programming works; I intend to implement the algorithm myself later.</p><h2 id=11-counting-server-paths-for-the-reactor>11 counting server paths for the reactor<a hidden class=anchor aria-hidden=true href=#11-counting-server-paths-for-the-reactor>#</a></h2><ol><li>We are given a directed graph of server devices, one line per device;</li><li>each line is <code>node: child1 child2 ...</code> meaning data flows from node to children;</li><li>part 1: count all distinct paths from <code>you</code> to <code>out</code>;</li><li>part 2: count all distinct paths from <code>svr</code> to <code>out</code> that pass through both <code>fft</code> and <code>dac</code>.</li></ol><p>We simply parse the data into a dict of parent-children pairs, with the children being a set.</p><p><a id=code-snippet--D11-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2511</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>set</span><span class=p>[</span><span class=nb>str</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse graph as parent -&gt; children sets.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>set</span><span class=p>[</span><span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span><span class=p>,</span> <span class=n>children</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>graph</span><span class=p>[</span><span class=n>parent</span><span class=p>]</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>children</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>graph</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D11</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=n>parse_2511</span><span class=p>(</span><span class=n>D11</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>),</span> <span class=nb>sum</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>values</span><span class=p>()))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>643 1738
</span></span></code></pre></td></tr></table></div></div><p>The core of the problem is counting paths in a directed acyclic graph. This is a classic dynamic programming problem, where the problem can be decomposed into multiple subproblems, and each subproblem of the same format as the overall problem. Besides, in each of the subproblem and sub-subproblems, the same computation has to be carried out repeatedly.</p><p>Because of this, we need to carefully manage two things, formulating the solution in a way that the same problem-solving logic can be reused, and memoization.</p><p><a id=code-snippet--D11-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>lru_cache</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>count_paths</span><span class=p>(</span><span class=n>graph</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>set</span><span class=p>[</span><span class=nb>str</span><span class=p>]],</span> <span class=n>start</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>end</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Count paths from start to end in a DAG.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nd>@lru_cache</span><span class=p>(</span><span class=n>maxsize</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span> <span class=o>==</span> <span class=n>end</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>)</span> <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=p>()))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dfs</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_251101</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 1: count paths from you to out.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    DFS + memoization on node.
</span></span></span><span class=line><span class=cl><span class=s2>    O(V+E) time, O(V) space.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=n>parse_2511</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count_paths</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=s1>&#39;you&#39;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s1>&#39;out&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_251101</span><span class=p>(</span><span class=n>D11</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>574
</span></span></code></pre></td></tr></table></div></div><p>I originally solved part 1 without considering any edge cases, since there was none; and I didn&rsquo;t even bother with memoization, since the computation is manageable without it. And then for part 2 I had to patch it up again and again to fix all the edge cases.</p><p>Recursive functions are hard to understand and reason with. It&rsquo;s better to print out the result of each iteration to understand how it&rsquo;s stacked up.</p><p>Part 2 adds some constraint: the path must pass through two specific nodes, <code>fft</code> and <code>dac</code>. Since one must be before the other, I used a rather silly approach to determine which is before which, but it worked. My original implementation for part 1 is quite limited, I used it to count <code>#(fft -> dac)</code>, if <code>fft</code> is before <code>dac</code> it will not finish, since I didn&rsquo;t use memoization and it&rsquo;s very slow; and if <code>dac</code> is before <code>fft</code> it will throw an error, since I didn&rsquo;t take such reverse direction cases into consideration. So using this weird method I figured out their order in the directed graph, and <code>fft</code> is upstream of <code>dac</code>.</p><p>That means every valid path factors into three independent segments: and we can count the unique paths of each segment independently, then multiply them together, i.e. <code>#(svr -> fft) * #(fft -> dac) * #(dac -> out)</code>.</p><p><a id=code-snippet--D11-02></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_251102</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Part 2: paths from svr to out passing through fft and dac.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Factor into three independent path counts.
</span></span></span><span class=line><span class=cl><span class=s2>    O(V+E) per segment, O(V) space.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=n>parse_2511</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>count0</span> <span class=o>=</span> <span class=n>count_paths</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=s1>&#39;svr&#39;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s1>&#39;fft&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>count1</span> <span class=o>=</span> <span class=n>count_paths</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=s1>&#39;fft&#39;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s1>&#39;dac&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>count2</span> <span class=o>=</span> <span class=n>count_paths</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=s1>&#39;dac&#39;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s1>&#39;out&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count0</span> <span class=o>*</span> <span class=n>count1</span> <span class=o>*</span> <span class=n>count2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_251102</span><span class=p>(</span><span class=n>D11</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>306594217920240
</span></span></code></pre></td></tr></table></div></div><h2 id=12-fitting-present-shapes-in-the-christmas-tree-farm>12 fitting present shapes in the Christmas tree farm<a hidden class=anchor aria-hidden=true href=#12-fitting-present-shapes-in-the-christmas-tree-farm>#</a></h2><ol><li>We are in the Christmas tree farm,</li><li>we have a number of Christmas presents, in one of the different shapes, all fitted in a 3x3 grid;</li><li>we also have a list of regions, each a rectangle of a given size, to accomodate the gifts;</li><li>gifts can be rotated or flipped; to be fitted into the given regions, but without overlap;</li><li>day 12 has only one problem, to count how many of the given regions can fit all required shapes.</li></ol><p>Parse the data:</p><ul><li>shapes into a dict of index:shape pairs,</li><li>regions into a nesting list of region width, length, and a tuple of required shape counts.</li></ul><p><a id=code-snippet--D12-parse></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_2512</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>dict</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>list</span><span class=p>[</span><span class=nb>str</span><span class=p>]],</span> <span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>]]]]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parse shapes and region specs.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>shapes</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>list</span><span class=p>[</span><span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>regions</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>]]]</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>rows</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>data</span><span class=o>.</span><span class=n>splitlines</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>line</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>line</span><span class=o>.</span><span class=n>endswith</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span> <span class=ow>and</span> <span class=n>line</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>isdigit</span><span class=p>():</span> <span class=c1># starting new shapes</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>shapes</span><span class=p>[</span><span class=n>current</span><span class=p>]</span> <span class=o>=</span> <span class=n>rows</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>line</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>rows</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=s1>&#39;x&#39;</span> <span class=ow>in</span> <span class=n>line</span> <span class=ow>and</span> <span class=s1>&#39;:&#39;</span> <span class=ow>in</span> <span class=n>line</span><span class=p>:</span> <span class=c1># starting new regions</span>
</span></span><span class=line><span class=cl>            <span class=n>area</span><span class=p>,</span> <span class=n>nums</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>w</span><span class=p>,</span> <span class=n>h</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>area</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;x&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>counts</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>nums</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>            <span class=n>regions</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>w</span><span class=p>,</span> <span class=n>h</span><span class=p>,</span> <span class=n>counts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span> <span class=c1># accumulating lines for current shape</span>
</span></span><span class=line><span class=cl>            <span class=n>rows</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>line</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>current</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>shapes</span><span class=p>[</span><span class=n>current</span><span class=p>]</span> <span class=o>=</span> <span class=n>rows</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>shapes</span><span class=p>,</span> <span class=n>regions</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D12</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>Puzzle</span><span class=p>(</span><span class=n>year</span><span class=o>=</span><span class=mi>2025</span><span class=p>,</span> <span class=n>day</span><span class=o>=</span><span class=mi>12</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shapes</span><span class=p>,</span> <span class=n>regions</span> <span class=o>=</span> <span class=n>parse_2512</span><span class=p>(</span><span class=n>D12</span><span class=o>.</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>shapes</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>regions</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>6 1000
</span></span></code></pre></td></tr></table></div></div><p>This is an interesting parsing problem, because the input data have two distinct parts which require different parsing logic. Also, the data parsing is line by line, but each shape takes up multiple lines, so we also need a way to accumulate lines for each shape.</p><p>As to the problem itself, this is a hard problem with a simple solution. We want to fit a number of irregular shaped presents into a regular rectangular region, there must be a minimum area requirement, where all the shapes fit perfectly together; and a maximum area requirement, where none of the shapes can fit together, and we thus have to spare a 3x3 grid for each of them. We can first check whether each region&rsquo;s area is in this <code>(minimum, maximum)</code> range, and filter out the regions that ain&rsquo;t. For regions with area less than the minimum no fitting is possible; for regions with areas bigger than the maximum we can simply put the gifts consecutively, each in a 3x3 grid, so the solution is trivial.</p><p><a id=code-snippet--D12-explore></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>shape_ids</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>shapes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>filled</span> <span class=o>=</span> <span class=p>[</span><span class=nb>sum</span><span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=s1>&#39;#&#39;</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>shapes</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>shape_ids</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>box</span> <span class=o>=</span> <span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>shapes</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>shapes</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>])</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>shape_ids</span><span class=p>]</span>  <span class=c1># 3x3 here</span>
</span></span><span class=line><span class=cl><span class=n>classifications</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>regions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>h</span><span class=p>,</span> <span class=n>counts</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>regions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>area</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>    <span class=n>compact</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>n</span> <span class=o>*</span> <span class=n>f</span> <span class=k>for</span> <span class=n>n</span><span class=p>,</span> <span class=n>f</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>counts</span><span class=p>,</span> <span class=n>filled</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>loose</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>n</span> <span class=o>*</span> <span class=n>b</span> <span class=k>for</span> <span class=n>n</span><span class=p>,</span> <span class=n>b</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>counts</span><span class=p>,</span> <span class=n>box</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>compact</span> <span class=o>&gt;</span> <span class=n>area</span><span class=p>:</span> <span class=c1># no solution possible</span>
</span></span><span class=line><span class=cl>        <span class=n>classifications</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>loose</span> <span class=o>&lt;=</span> <span class=n>area</span><span class=p>:</span> <span class=c1># no work necessay</span>
</span></span><span class=line><span class=cl>        <span class=n>classifications</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=nb>sum</span><span class=p>(</span><span class=n>c</span><span class=o>==</span><span class=n>i</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>classifications</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>0 0
</span></span><span class=line><span class=cl>1 519
</span></span><span class=line><span class=cl>2 481
</span></span></code></pre></td></tr></table></div></div><p>As it turns out, of the 1000 problem regions, 519 of them are not possible, 481 of them are trivial, and none of them requires actual work. So the feasible ones are identical to the trivial ones.</p><p><a id=code-snippet--D12-01></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_2512</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>c</span><span class=o>==</span><span class=mi>2</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>classifications</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>solve_2512</span><span class=p>(</span><span class=n>D12</span><span class=o>.</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>481
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://riversdark.github.io/stats/eight/><span class=title>Next »</span><br><span>Eight Schools, or the importance of model reparameterisation</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://riversdark.github.io/>Lottery of Babylonian Variations</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>